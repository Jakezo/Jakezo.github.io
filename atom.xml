<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Re-Coder</title>
  
  
  <link href="http://jakezo.github.io/atom.xml" rel="self"/>
  
  <link href="http://jakezo.github.io/"/>
  <updated>2021-06-08T06:30:33.342Z</updated>
  <id>http://jakezo.github.io/</id>
  
  <author>
    <name>Jakezo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-Basic-01</title>
    <link href="http://jakezo.github.io/2021/06/06/spring-Basic-01/"/>
    <id>http://jakezo.github.io/2021/06/06/spring-Basic-01/</id>
    <published>2021-06-06T04:30:45.000Z</published>
    <updated>2021-06-08T06:30:33.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="스프링-시작하기"><a href="#스프링-시작하기" class="headerlink" title="스프링 시작하기"></a>스프링 시작하기</h2><p>스프링 개발에서 가장 많이 사용하는 통합 개발 도구는</p><ul><li>Eclips 기반의 STS</li><li>Intellij 혹은 Eclipse에 플러그인을 설치하는 형태</li></ul><p>로 사용하는 경우가 많습니다.</p><p>STS를 설치하는 방법으로 진행하며 JDK 1.6이상의 버전 설치는 필수 입니다.</p><h2 id="스프링-프로젝트-시작-방법"><a href="#스프링-프로젝트-시작-방법" class="headerlink" title="스프링 프로젝트 시작 방법"></a>스프링 프로젝트 시작 방법</h2><p>STS 설치하면 Spring 으로 웹 프로젝트를 시작하는 방법은 2가지가 있습니다</p><ol><li><p> Spring Boot를 이용하는 프로젝트의 생성 (Spring Starter Project) 이며</p></li><li><p>스프링의 템플릿 프로젝트를 이용하여 프로젝트의 생성 (Spring Project) 방법으로 나뉩니다.</p></li></ol><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul><li><p><code>Spring Boot</code>는 빠른 개발이 필요하거나 최신 트랜드에 민감할 경우 사용합니다.</p></li><li><p><code>Spring Boot</code>의 목적은 최대한 간단하게 실행하고 배포가 가능한 수준의 웹 애플리케이션을 제작하는 것입니다.</p></li></ul><p>즉, 개발에 필요한 기본적인 모든 환경설정을 맞춰주고 <code>최소한의 개발</code>을 해야하는 경우 사용합니다.</p><p>그러나, 협업을 하거나 Tomcat과 같은 WAS를 사용한다면 <strong>Spring Project</strong>를 사용하여야 합니다.</p><h3 id="Spring-Project"><a href="#Spring-Project" class="headerlink" title="Spring Project"></a>Spring Project</h3><p><code>Spring Starter Project</code>의 경우는 2014년에 개발된 Spring Boot라는 스프링의 하위 프로젝트를 이용해서 작성하는 방법입니다. Spring Boot를 사용하면 개발자가 복잡한 설정없이도 모든 개발환경이 준비되기때문에 기존에 Spring으로 개발 경험이 없는 개발자라도 쉽게 웹 프로젝트를 실행할 수 있습니다.</p><p>Spring Boot는 WAS 설정 없이 실행 가능하며 설치가 쉽습니다.</p><p><sub>Dependency가 Spring Booth 가 더욱 간단하고 전체적으로 Spring Booth 는 개발자가 개발에만 집중할 수 있도록 만들어져 있다.<sub/></p><table><thead><tr><th></th><th align="center">Spring Booth</th><th align="right">Spring Project</th></tr></thead><tbody><tr><td><code>장점</code></td><td align="center">* WAS 필수요소X<br/> * 별도의 설정이 필요 X<br/> 로딩시간이 짧아 테스트에 용이</td><td align="right">* 실무에 사용<br/> * 자료가 다양<br/>* 모든 스프링에서 사용가능</td></tr><tr><td><span style="color:red">단점</span></td><td align="center">* 기존의 설정과 다른 방식으로 사용 <br/>* JSP 설정 등은 별도로 해야함</td><td align="right">* 초반 테스트 환경 구성이 어려움<br/> * WAS와 연동하는 경우 결과 확인에 많은 리소스를 소모</td></tr></tbody></table><h2 id="Spring-MyBatis-MySQL-설치-및-연동"><a href="#Spring-MyBatis-MySQL-설치-및-연동" class="headerlink" title="Spring + MyBatis + MySQL 설치 및 연동"></a>Spring + MyBatis + MySQL 설치 및 연동</h2><h3 id="MyBatis란"><a href="#MyBatis란" class="headerlink" title="MyBatis란?"></a>MyBatis란?</h3><p>MyBatis는 Spring프로젝트에서 SQL 처리를 도와주는 형태로 JDBC와 유사합니다.</p><p>하지만 JDBC와 비교하면 다음과 같은 장점을 제공합니다.</p><ul><li>**간결한 코드의 처리 **</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;스프링-시작하기&quot;&gt;&lt;a href=&quot;#스프링-시작하기&quot; class=&quot;headerlink&quot; title=&quot;스프링 시작하기&quot;&gt;&lt;/a&gt;스프링 시작하기&lt;/h2&gt;&lt;p&gt;스프링 개발에서 가장 많이 사용하는 통합 개발 도구는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ecl</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java-BufferedReader</title>
    <link href="http://jakezo.github.io/2021/05/22/java-BufferedReader/"/>
    <id>http://jakezo.github.io/2021/05/22/java-BufferedReader/</id>
    <published>2021-05-22T14:22:19.000Z</published>
    <updated>2021-06-08T06:30:33.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BufferedReader-BufferedWriter"><a href="#BufferedReader-BufferedWriter" class="headerlink" title="BufferedReader, BufferedWriter"></a>BufferedReader, BufferedWriter</h2><ul><li><p>버퍼를 이용해 읽고 쓰는 함수</p></li><li><p>버퍼를 이용해 읽고 쓰기 때문에 입출력 효율이 Scanner, System.out.println(“”) 등 보다 훨씬 좋다.</p></li><li><p>입력된 데이터가 바로 전달되지 않고 중간에 버퍼링이 된 후에 전달된다.</p></li><li><p>출력 역시 버퍼를 거쳐 간접적으로 출력장치로 전달되기에 입출력이 효율적이다.</p></li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul><li><p>데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 임시 메모리 영역</p></li><li><p>입출력 속도 향상을 위해 사용</p></li></ul><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><ul><li>버퍼를 이용한 입력</li></ul><h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><ul><li>버퍼를 이용한 출력</li></ul><p>왜? 사용하는데?<br>하드디스크는 원래 속도가 엄청 느리다. 뿐만 아니라 키보드나 모니터와 같은 외부 장치와의 데이터 입출력은 생각보다 시간이 걸리는 작업이다. 버퍼링 없이 키보드가 눌릴 때마다 눌린 문자의 정보를 목적지로 바로 이동시키는 것보다 중간에 메모리 버퍼를 두어 데이터를 한 데 묶어서 이동시키는 것이 보다 효율적이고 빠르다.</p><p>그냥 전송하게 되면 CPU와 성능 갭이 많이 나서 비효율적이다.</p><p>흙을 파서 언덕에 버리는데, 한 번 삽질할 때마다 가서 버리는 것보다, 수레에 가득 채워서 한 번에 나르는 것이 효율적인 것과 같은 이치.</p><p>즉, 모아뒀다가 한 번에 전송하는게 훨씬 효율적!</p><h2 id="BufferedReader-1"><a href="#BufferedReader-1" class="headerlink" title="BufferedReader"></a>BufferedReader</h2><h3 id="Scanner-VS-BufferedReader"><a href="#Scanner-VS-BufferedReader" class="headerlink" title="Scanner VS BufferedReader"></a>Scanner VS BufferedReader</h3><p>Scanner를 통해 입력을 받을 경우 Space, Enter를 모두 경계로 인식하기에 입력받은 데이터를 가공하기 매우 편리하다.</p><p>하지만 BufferedReader는 Enter만 경계로 인식하고 입력 데이터가 String로 고정되기 때문에 입력받은 데이터를 가공하는 작업이 필요할 경우가 많다.</p><p>하지만 많은 양의 데이터를 입력 받을 경우 BufferedReader를 통해 입력받는 것이 효율적</p><h3 id="BufferedReader-사용법"><a href="#BufferedReader-사용법" class="headerlink" title="BufferedReader 사용법"></a>BufferedReader 사용법</h3><p>BufferedReader 선언 후 readLine() 메소드를 이용해 데이터를 라인 단위로 읽어옴.</p><p>readLine()의 리턴 값은 String으로 고정되기에 다른 타입으로 입력을 받으려면 형 변환을 해주어야 한다.</p><blockquote><p>예외처리는 필수</p></blockquote><p>BufferedReader 사용을 위해 throws IOException 이용하거나 try &amp; catch를 활용해 예외처리를 해주어야한다.</p><p>아래 코드는 try &amp; catch로 예외처리 한 경우</p><p>그냥 BufferedReader만 쓰면 알아서 Eclipse에서 import하라고 경고를 줌(누르면 바로 IOException 적용 가능)</p><pre><code class="java">import java.io.*;import java.util.StringTokenizer;public class Main &#123;    public static void main(String[] args) &#123;        try &#123;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            String s = br.readLine(); //String            int i = Integer.parseInt(br.readLine()); //int            // br.readLine()으로 읽어온 데이터 가공            // 1. 공백 단위로 구분해 nextToken()을 통해 순서대로 호출            StringTokenizer st = new StringTokenizer(br.readLine());            int T = Integer.parseInt(st.nextToken());            int N = Integer.parseInt(st.nextToken());            String array[] = s.split(&quot; &quot;); // 2. 공백 단위로 데이터 끊어서 배열에 넣음        &#125; catch (IOException e) &#123;            e.printStackTrace();            System.out.println(e.getMessage());        &#125;    &#125;&#125;</code></pre><p>Read 한 데이터는 Line단위로만 나눠지기에 공백 단위로 데이터를 가공하려면 따로 작업을 해야 한다.</p><p>첫 번째로 StringTokenizer에 nextToken() 함수를 쓰면 readLine()을 통해 입력받은 값을 공백 단위로 구분해 nextToken()을 통해 순서대로 호출할 수 있다.</p><p>두 번째는 String.split() 함수를 이용해 배열에 공백 단위로 끊어서 데이터를 넣어 사용한다.</p><h2 id="BufferedWriter-1"><a href="#BufferedWriter-1" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h2><p>System.out.println(“”);와 같이 데이터를 출력하는 함수이다.</p><p>많은 양의 출력에서는 입력과 마찬가지로 Buffer를 활용하기 때문에 효율적이다.</p><p>BufferedWriter의 경우 버퍼를 잡아 놓았기 때문에 반드시 flush()를 통해 버퍼에 남아있는 데이터를 모두 출력하고,</p><p>close()를 호출해 스트림을 닫아야 한다.</p><p>bw.write에는 System.out.println();과 같이 자동 개행 기능이 없기 때문에 개행을 해주어야 할 경우에는 \n를 통해 따로 처리해 주어야 한다.</p><pre><code class="java">import java.io.*;public class Main &#123;    public static void main(String[] args) throws IOException &#123;        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));        String s = &quot;minha&quot;;// 출력할 문자열        bw.write(s + &quot;\n&quot;); // 출력        bw.flush(); // 남아있는 데이터를 모두 출력시킴        bw.close(); // 스트림을 닫음    &#125;&#125;   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BufferedReader-BufferedWriter&quot;&gt;&lt;a href=&quot;#BufferedReader-BufferedWriter&quot; class=&quot;headerlink&quot; title=&quot;BufferedReader, BufferedWriter&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jakezo.github.io/categories/JAVA/"/>
    
    
    <category term="Java" scheme="http://jakezo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-basic-02</title>
    <link href="http://jakezo.github.io/2021/05/13/java-basic-02/"/>
    <id>http://jakezo.github.io/2021/05/13/java-basic-02/</id>
    <published>2021-05-13T05:25:44.000Z</published>
    <updated>2021-05-13T06:26:23.978Z</updated>
    
    <content type="html"><![CDATA[<p><sub>기본적인 자바에 대해 부족한 부분을 보충해서 포스팅 해봅니다 크롬에 최적화 되어있습니다.</sub></p><h2 id="추상메소드"><a href="#추상메소드" class="headerlink" title="추상메소드"></a>추상메소드</h2><blockquote><p>추상 메소드란 메소드의 시그니처만이 정의된 비어있는 메소드를 의미한다. 아래의 코드를 보자.</p></blockquote><pre><code class="java">package org.opentutorials.javatutorials.abstractclass.example1;abstract class A&#123;    public abstract int b();    //본체가 있는 메소드는 abstract 키워드를 가질 수 없다.    //public abstract int c()&#123;System.out.println(&quot;Hello&quot;)&#125;    //추상 클래스 내에는 추상 메소드가 아닌 메소드가 존재 할 수 있다.     public void d()&#123;        System.out.println(&quot;world&quot;);    &#125;&#125;public class AbstractDemo &#123;    public static void main(String[] args) &#123;        A obj = new A();    &#125;&#125;</code></pre><ul><li>위 코드의 실행 결과는 아래와 같다.</li></ul><pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem:     Cannot instantiate the type A    at org.opentutorials.javatutorials.abstractclass.example1.AbstractDemo.main(AbstractDemo.java:7)</code></pre><p> 메소드 b의 선언 부분에는 abstract라는 키워드가 등장하고 있다. 이 키워드는 메소드 b는 메소드의 시그니처만 정의 되어 있고 이 메소드의 구체적인 구현은 하위 클래스에서 오버라이딩 해야 한다는 의미다. 이렇게 내용이 비어있는 메소드를 추상 메소드라고 부른다. 추상 메소드를 하나라도 포함하고 있는 클래스는 추상 클래스가 되고, 자연스럽게 클래스의 이름 앞에 abstract가 붙는다. </p><hr><h3 id="에스프레소-문제"><a href="#에스프레소-문제" class="headerlink" title="에스프레소 문제"></a>에스프레소 문제</h3><pre><code class="java">package ex01_abstract;/** 추상 메소드    * 1. abstract method* 2. 형태가 없는 메소드* 3. 본문이 없는 메소드* 4. 작성 방법*    abstract 결과타입 메소드명(매개변수);* * 추상 클래스* 1. abstract class* 2. 형태가 없는 클래스* 3. new가 불가능한 클래스* 4. 추상 메소드를 하나라도 가지고 있으면 추상 클래스* 5. 작성 방법*    abstract class 클래스명 &#123;*        abstract 결과타입 메소드명(매개변수);*    &#125;* 6. 추상 클래스를 상속 받는 서브클래스들은*    반드시 추상 메소드를 오버라이드 해야 한다.*/abstract class Coffee &#123;   // field   private String beanOrigin;   // constructor   public Coffee(String beanOrigin) &#123;       super();       this.beanOrigin = beanOrigin;   &#125;   // method   // 일반 메소드   public void info() &#123;       System.out.println(&quot;커피원산지: &quot; + beanOrigin);   &#125;   // 추상 메소드 (본문을 작성할 필요가 없는 메소드)   public abstract void taste();&#125;class Espresso extends Coffee &#123;   // field   private int water;   // constructor   public Espresso(String beanOrigin, int water) &#123;       super(beanOrigin);       this.water = water;   &#125;   // method   // 일반 메소드는 오버라이드를 하던지 말던지 알아서 처리   // 추상 메소드는 반드시 오버라이드를 해야 함   @Override   public void info() &#123;       super.info();  // 커피원산지       System.out.println(&quot;물의 양: &quot; + water);   &#125;   @Override   public void taste() &#123;       System.out.println(&quot;Espresso는 쓰다.&quot;);   &#125;&#125;class Latte extends Espresso &#123;   // field   private int milk;   // constructor   public Latte(String beanOrigin, int water, int milk) &#123;       super(beanOrigin, water);       this.milk = milk;   &#125;   // method   @Override   public void info() &#123;       super.info();  // 커피원산지, 물       System.out.println(&quot;우유의 양: &quot; + milk);   &#125;   @Override   public void taste() &#123;       System.out.println(&quot;Latte는 부드럽다.&quot;);   &#125;&#125;public class Ex01_Coffee &#123;   public static void main(String[] args) &#123;       // new Coffee(&quot;콜롬비아&quot;);  // 추상 클래스는 new를 할 수 없다.       Coffee[] list = new Coffee[2];  // 객체 생성하는 new가 아님       list[0] = new Espresso(&quot;탄자니아&quot;, 30);       list[1] = new Latte(&quot;케냐&quot;, 30, 150);       for (Coffee coffee : list) &#123;           if (coffee != null) &#123;               coffee.info();               coffee.taste();           &#125;       &#125;   &#125;&#125;</code></pre><h3 id="결과값"><a href="#결과값" class="headerlink" title="결과값"></a>결과값</h3><img src="https://i.esdrop.com/d/1YZmfhSWOT/jWCQlfvxs7.png"/><hr><blockquote><p>아래 예제는 abstrct 를 이용한 계산기 문제 입니다.</p></blockquote><h3 id="계산기-문제"><a href="#계산기-문제" class="headerlink" title="계산기 문제"></a>계산기 문제</h3><pre><code class="java">package practice;abstract class Calculator&#123;    int left, right;    public void setOprands(int left, int right)&#123;        this.left = left;        this.right = right;    &#125;     public abstract void sum();      public abstract void avg();    public void run()&#123;        sum();        avg();    &#125;&#125;class CalculatorDecoPlus extends Calculator &#123;    public void sum()&#123;        System.out.println(&quot;+ sum :&quot;+(this.left+this.right));    &#125;    public void avg()&#123;        System.out.println(&quot;+ avg :&quot;+(this.left+this.right)/2);    &#125;&#125; class CalculatorDecoMinus extends Calculator &#123;    public void sum()&#123;        System.out.println(&quot;- sum :&quot;+(this.left+this.right));    &#125;    public void avg()&#123;        System.out.println(&quot;- avg :&quot;+(this.left+this.right)/2);    &#125;&#125; public class Q01_abstract &#123;    public static void main(String[] args) &#123;         CalculatorDecoPlus c1 = new CalculatorDecoPlus();            c1.setOprands(10, 20);            c1.run();            CalculatorDecoMinus c2 = new CalculatorDecoMinus();            c2.setOprands(10, 30);            c2.run();        &#125;    &#125;</code></pre><h3 id="결과값-1"><a href="#결과값-1" class="headerlink" title="결과값"></a>결과값</h3><img src="https://i.esdrop.com/d/1YZmfhSWOT/82thJ2xi5A.png"/>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;sub&gt;기본적인 자바에 대해 부족한 부분을 보충해서 포스팅 해봅니다 크롬에 최적화 되어있습니다.&lt;/sub&gt;&lt;/p&gt;
&lt;h2 id=&quot;추상메소드&quot;&gt;&lt;a href=&quot;#추상메소드&quot; class=&quot;headerlink&quot; title=&quot;추상메소드&quot;&gt;&lt;/a&gt;추상메</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jakezo.github.io/categories/JAVA/"/>
    
    
    <category term="Java" scheme="http://jakezo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-basic-01</title>
    <link href="http://jakezo.github.io/2021/05/11/java-basic-01/"/>
    <id>http://jakezo.github.io/2021/05/11/java-basic-01/</id>
    <published>2021-05-11T08:59:40.000Z</published>
    <updated>2021-05-11T09:16:40.245Z</updated>
    
    <content type="html"><![CDATA[<p><sub>기본적인 자바에 대해 부족한 부분을 보충해서 포스팅 해봅니다.</sub></p><h2 id="자바-인스턴스와-정적-멤버"><a href="#자바-인스턴스와-정적-멤버" class="headerlink" title="자바 인스턴스와 정적 멤버"></a>자바 인스턴스와 정적 멤버</h2><p>클래스에 선언된 필드와 메소드가 모두 객체 내부에 포함되는 것은 아닙니다. 일부는 포함이 되지 않고 클래스에 그대로 남아있는 것도 있습니다. 클래스는 객체의 설계도입니다. 클래스 멤버필드, 메소드는 당연히 객체에도 포함되어야합니다. 그러므로 객체가 여러 개일 경우 클래스 멤버필드와 메소드는 객체의 개수만큼 존재해야 합니다. 하지만 객체의 필드값이 모두 같다면 이 필드를 모든 객체가 가질 필요가 있을까요? 자바는 이런 경우를 위해 클래스 멤버를 인스턴스 멤버와 정적 멤버로 구분해서 선언할 수 있도록 하고 있습니다.</p><h3 id="인스턴스-멤버와-this"><a href="#인스턴스-멤버와-this" class="headerlink" title="인스턴스 멤버와 this"></a>인스턴스 멤버와 this</h3><p>인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부릅니다. 우리가 지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버였습니다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없습니다.</p><h3 id="인스턴스-멤버-선언"><a href="#인스턴스-멤버-선언" class="headerlink" title="인스턴스 멤버 선언"></a>인스턴스 멤버 선언</h3><p>인스턴스 필드와 메소드를 선언하는 방법은 지금까지 선언한 방식입니다. 특별한 것이 없이 그냥 필드와 메소드를 선언한 것입니다. 지금 살펴봐야하는 것은 선언이 아닌 선언후에 사용하는 방법입니다. 인스턴스 멤버는 객체가 생성된 후에야 사용이 가능합니다. 이전에도 설명드렸던 것 처럼 객체는 힙영역에 생성됩니다. 각각의 객체를 생성할 때마다 새로운 힙영역이 할당됩니다. 그래서 그 객체에 인스턴스 멤버가 할당되고 사용할 수 있는 것입니다. 하지만 자바에서는 힙영역과 스택영역외에 메소드 영역이 있습니다. 정적필드/상수, 생성자 코드, 메소드 코드 등을 저장하고 있습니다. 클래스에 선언된 것 중에 반복적으로 사용될 수 있는 것들을 모아놓은 곳이지요. 인스턴스 멤버는 이 영역에 존재하지 않기때문에 객체를 생성할 때 힙영역에 할당받게 됩니다.</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있습니다. 우리가 우리 자신을 ‘나’라고 가리키듯이 객체는 자신을 this라고 합니다. this는 주로 클래스의 메소드나 생성자 내부에서 클래스자신의 멤버와 매개변수인 멤버를 구분지을 때 사용됩니다. </p><h3 id="정적-멤버와-static"><a href="#정적-멤버와-static" class="headerlink" title="정적 멤버와 static"></a>정적 멤버와 static</h3><p>정적(static)은 ‘고정된’이란 의미입니다. 정적 멤버는 클래스에 고정된 멤버로서 아까 얘기한 메소드 영역에 존재합니다. 그래서 객체를 생성하지 않아도 사용이 가능합니다. 이들을 각각 저적 필드와 정적 메소드라고 부릅니다.</p><h3 id="정적-멤버-선언"><a href="#정적-멤버-선언" class="headerlink" title="정적 멤버 선언"></a>정적 멤버 선언</h3><p>정적 필드와 정적 메소드를 선언하려면 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 됩니다. 정적 필드는 클래스 하나만 존재하기때문에 모든 객체에서 같은 값을 갖게됩니다. 그래서 선언을 할 때 객체마다 값을 가져야 할 필요가 있으면 인스턴스 필드로 선언하고 공통된 값을 가진다면 정적필드로 선언하면 됩니다.</p><h3 id="정적-멤버-사용"><a href="#정적-멤버-사용" class="headerlink" title="정적 멤버 사용"></a>정적 멤버 사용</h3><p>정적 멤버는 객체와 상관없이 사용하는 멤버이기 때문에 클래스 이름과 함께 도트(.) 연산자로 접근합니다. 그래서 객체를 생성하지 않아도 멤버에 접근이 가능합니다.</p><img src="https://i.esdrop.com/d/1YZmfhSWOT/gdHbAN24OZ.jpg"/><img src="https://i.esdrop.com/d/1YZmfhSWOT/6i9sc6zgWO.jpg"/><p>위의 프로그램에서는 객체를 전혀 생성하지 않았습니다. 그것은 정적멤버들만 사용했기 때문입니다. 위에서 본 것 처럼 정적 필드와 정적 메소드는 객체를 생성하지 않고서도 사용할 수 있습니다. pi같은 값은 어디서나 같은 값이기 때문에 정적 필드가 가장 적합합니다. plus나 minus 같은 메소드도 인스턴스 멤버를 사용하지 않기때문에 정적 메소드를 사용했습니다.</p><blockquote><p>정적 메소드 선언 시 주의할 점</p></blockquote><p>객체가 없어도 실행된다는 특징 때문에 정적 메소드를 선언할 때는 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없습니다. 또한 객체 자신의 참조인 this 키워드도 사용이 불가능합니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;sub&gt;기본적인 자바에 대해 부족한 부분을 보충해서 포스팅 해봅니다.&lt;/sub&gt;&lt;/p&gt;
&lt;h2 id=&quot;자바-인스턴스와-정적-멤버&quot;&gt;&lt;a href=&quot;#자바-인스턴스와-정적-멤버&quot; class=&quot;headerlink&quot; title=&quot;자바 인스턴스와 정적</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jakezo.github.io/categories/JAVA/"/>
    
    
    <category term="Java" scheme="http://jakezo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java-operation</title>
    <link href="http://jakezo.github.io/2021/05/07/java-operation/"/>
    <id>http://jakezo.github.io/2021/05/07/java-operation/</id>
    <published>2021-05-07T08:36:16.000Z</published>
    <updated>2021-05-07T08:40:57.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="public-static-void-main-String-args-메인의-의미는-무엇인가"><a href="#public-static-void-main-String-args-메인의-의미는-무엇인가" class="headerlink" title="public static void main(String[] args) 메인의 의미는 무엇인가??"></a>public static void main(String[] args) 메인의 의미는 무엇인가??</h2><hr><p>static 이 무엇인지 void는 무엇인지 하나 하나의 특성을 알아가면서 정작 코딩을 할 때는</p><p>왜 이렇게 하지? public class ABCD { 왜 여기에는 static 을 안붙이고 void는 왜 안붙이지? 라는 생각을 매번 했습니다….ㅠㅠ</p><p>그러다 결국 이클립스에서 하는 main + space 를 누르면 항상 자동완성 되는 public static void main(String[] args) </p><p>이 부분에 대해서 검색해봤습니다.</p><p>결국에 찾다가 상당히 좋은 글을 보았기에 출처와 함께 퍼왔습니다.</p><p>초보자인 저에게는 상당한 도움이 되는 글이니 혹여나 다른 초보자분들도 보셨으면 이해가 쉽게 되실거라 생각됩니다!</p><hr><p>일단 가장 중요한 public static void main(String[] args)부터 이야기 하는데</p><p>그 전에 그 밑의 public, static, void 등에 관해 먼저 읽고 오는걸 추천한다.</p><p>일단 Java에서 main이 가지고 있는 의미부터 이야기를 해야 할 텐데,</p><p>Java에서 얼마나 길고 많은 내용을 포함하고 있던지 간에,</p><p>무조건 다른 부분에 앞서 제일 먼저 시작하는 시작점(Entry Point)이 있다.</p><p>그 시작점의 역할을 하는 부분이 바로 main인데,</p><p>다른 클래스, 메소드를 인스턴스화 하던 멀 하던</p><p>메인에서부터 시작되지 않으면 의미가 없는 것이고,</p><p>Java에서는 결국 메인에서 시작해서 메인에서 끝난다는 정도만 알면 될 듯 하다.</p><p>그럼 그 main을 실행하는 데 있어 메인에서 다른 클래스 메소드 등을 호출해서 사용하는데,</p><p>막상 main 자체가 다른 곳에서 접근을 허용하지 않는다면, 문제가 생길수 밖에 없기에</p><p>가장 넓은 범위로 접근을 허용하는 public을 사용하는 것이다.</p><p>public이 아닌 protected나 private로 지정할 경우 타 클래스로 부터의 접근에 문제가 생겨</p><p>가장 중심이 되어야 할 main으로서의 기능 자체를 상실하게 되는 것이다.</p><p>또한 static을 명령어로 지정하는 이유는,</p><p>static의 특징이 프로그램이 시작하면서 따로 인스턴스 하지 않아도</p><p>프로그램의 시작과 동시에 static으로 선언된 것들은 메모리에 호출이 되어 지는데,</p><p>이렇게 호출된 것들은 다른 녀석들과는 다르게 프로그램이 종료되는 시점까지 계속 유지가 된다는 점이다.</p><p>다른 클래스, 메소드, 변수 등의 경우 Java Virtual Machine의 Garbage Collector에 의해</p><p>인스턴스화 되어 사용이 되어진다 하더라도, 일정 용도를 끝 마친 후에는 다시 메모리에서 삭제가 되거나,</p><p>다른 부분에서 참조가 되지 않는 부분 등이 있는데,</p><p>static으로 선언된 것은 끝까지 살아남아 계속 참조를 할 수 있는 특징이 있으므로,</p><p>프로그램에서 시작과 끝을 함께하는 main 메소드가 일정 시간만 살아있고 폐기되어서는 곤란하므로</p><p>계속 살아남아 역할을 하기위해서는 static 명령어가 꼭 필요하다고 할 수 있다.</p><p>void의 경우 메소드에 return 값이 없다는 뜻인데, main에서 void를 사용 하는 것은</p><p>main 자체가 하나의 프로그램의 시작과 끝인데,</p><p>프로그램 자체가 종료가 되는 시점에서 어떤 특정 값이 반환된다 한들 그 값이</p><p>의미를 가질리도 없고, 의미를 가져서도 안 된다.</p><p>어떤 계산에 의한 값의 반환이 있다면 그건 어디까지나 프로그램이 종료 되기 전에 이루어져야 하고</p><p>그 반환된 값 역시 프로그램이 종료되기 전 사용이 되어야 정상적인 것이므로</p><p>프로그램의 시작과 끝이 함께하는 main 메소드에는 반환값이 없는 void가 필요하다.</p><p>다음으로 String[] args가 있는데</p><p>여기 쓰이는 String은 우리가 흔히 사용하는 그 String과 같은 녀석으로 []를 통해 배열로 생성이 된다는 의미이다.</p><p>args의 경우 일반적으로 이렇게 사용할 뿐 원한다면 그 이름은 얼마든지 다른 것들로 대체할 수 있다.</p><p>String[] aabb 역시 성립한다는 의미이다.</p><p>또한 배열의 특징상 String args[] 역시 사용 가능하다.</p><p>이 명령어는 맨 처음 프로그램을 실행하는 데 있어</p><p>외부에서 값을 받아오기 위해서 사용하는 것인데,</p><p>예를 들어 Example01.class라는 이름으로 클래스를 생성하고 실행한다면,<br>java Example01.class 라는 명령어를 통해 실행이 되는데,</p><p>java Example01.class 100 200 이런 식으로 맨 처음 프로그램을 실행하는 순간 특정한 값을 입력하고자 할 경우</p><p>그렇게 입력한 100 200이 String 타입의 배열 args[0], args[1]에 저장이 되어</p><p>프로그램 안에서 사용할 수 있다는 것이다.</p><p>이렇게 사용하는 것을 매개변수라고 하는데, </p><p>main에서 String[] args라고 선언을 하는 이유는 </p><p>프로그램의 실행 순간 외부값을 가져와서</p><p>프로그램 안에 사용하고자 할 때 메모리에 저장할 공간을 미리 선언해 두는 것이라고 할 수 있다.</p><p>습관적으로 늘 맨 앞에 붙이는 이 public 이란 녀석은 기본적으로 접근 권한에 관한 이야기를 말한다.</p><p>‘접근제어자’라는 이름으로 통합하여 이야기 할 수 있는데</p><p>이 접근제어자에는 public을 포함할 뿐 아니라 다양한 접근제어자가 존재한다.</p><p>public을 이야기하는데 빠뜨릴 수 없는게 [public,   protected,   private,   (default)] 라는 녀석들이고,</p><p>이 녀석들 뿐만 아니라 [static, final, abstract] 등 도 상황에 따라 접근제어자로 구분이 될 수 있을 듯하다.</p><p>static을 포함한 녀석들은 아래에 다시 언급할 예정이니 넘어가고 위에 있는 4가지를 가지고 이야기를 해야겠다.</p><p>일단 public, protected, private, (default) 이렇게 4가지가 세트인데</p><p>모두 클래스, 메소드, 변수, 필드의 앞에 붙어서 선언 가능한 녀석들이다.</p><p>다만 이 중 (default)는 클래스, 메소드, 변수 등의 앞에 default 라고 쓰면서 사용이 되는게 아닌,</p><p>맨 앞에 아무것도 쓰지 않은 (공백)의 상태를 의미하는 점 주의하면 된다.</p><p>이걸 클래스 앞에 붙이느냐, 메소드 앞에 붙이느냐, 변수 앞에 붙이느냐, 필드 앞에 붙이느냐에 따라</p><p>각각의 용도가 조금씩 차이가 나는데, 기본적인 내용 자체에는 크게 차이가 없으니</p><p>세부적인 내용은 아래 위에 추천한 사이트에 방문하여 보도록 하고,</p><p>간단한 내용만 적어보자면,</p><p>public은 어디서나 상속 및 참조가 가능하다는 의미이다.</p><p>protected는 같은 패키지의 내부 혹은 이 클래스를 상속한 클래스에서만 접근을 허용한다는 의미이다..</p><p>private는 오직 이 클래스를 포함하고 있는 클래스 내부에서만 상속 및 참조를 허용한다는 의미이다.</p><p>(default)는 같은 패키지 내에서만 상속 및 참조가 가능하다는 의미이다.</p><p>이 중 protected와 private의 경우 항상 사용하는 것이 아니고,</p><p>다른 클래스 내에서 중첩된 클래스가 있는 경우 등에 사용하는 것이기에, 일반적으로 많이 사용되는 것은 아니다.</p><p>물론 위에 써 놓은건 아주 일반론적인 이야기일뿐, 머 줏어들은 이야기지만,</p><p>나중에 실제 복잡한 프로그래밍을 하게 되면, 데이터가 엉키는 것을 방지해</p><p>굉장히 많은 변수 등에 접근을 막아 놓게 되는 경우가 있다고 한다.</p><p>이건 나중에 상위 레벨로 올라가면서 점차 몸으로 직접 느끼게 되지 않을까 생각한다.</p><p>기본적으로 우리가 클래스를 인스턴스 시키고 변수를 선언하고 하면</p><p>그것은 특정부분에서만 사용 가능한 지역(local)의 의미만을 가지는데,</p><p>static은 그런 local의 범위를 벗어나 다른 곳들에서도 사용 할 수 있다(정적)는 의미로 사용된다.</p><p>클래스, 메소드, 변수 등에 모두 선언이 가능한데,</p><p>어디에 선언을 하냐에 따라 그 의미가 조금씩 달라지기는 하지만,</p><p>적어도 프로그램 전체에 영향을 미친다는 점에서는 같은 의미를 가지고 있다.</p><p>보통 일반적인 값들은 인스턴스 되면서 stack이나 heap 영역에 메모리가 생성이 되지만</p><p>static은 프로그램의 생성과 동시에 그 값이 선언이 되어,</p><p>statck, heap이 아닌 다른 메모리 영역에 할당 된다는 특징이 있다.</p><p>이걸 다르게 이야기한다면, 일반적인 클래스 메소드 변수의 경우</p><p>main안에서 혹은 특정 클래스 안에서 생성되지 않은 채로 기다리고 있다가</p><p>선언을 하는 순간 생성이 되고 다 사용하고 용도가 없어지면 지워진다는 특징이 있다면,</p><p>static은 특정 선언의 단계가 없더라도, 프로그램의 생성 시 이미 메모리 상에 상주를 하게 되고,</p><p>그렇게 생성된 값들을 이용하기만 하면 된다는 것이다.</p><p>static 과 개념은 조금 다르지만, 같이 이야기를 해야 할 녀석으로는 final이란 녀석이 있는데,</p><p>final은 값(혹은 내용)을 고정하여 처음에 선언한 그대로만 사용이 가능하여</p><p>그 값을 변화시킬 수 없다는 특징이 있다.</p><p>일반적으로 static과 콤비로 같이 사용하게 되는 경우가 많아 이렇게 묶어서 이야기 하는것 뿐이다.</p><p>final 같은 경우 특정 상황에 대비하여 특정 상황에서 프로그램을 강제 종료시키는 코드를 짤 때</p><p>강제 종료시키는 명령값으로 조건을 설정하는데 사용할 수 있는데,</p><p>강제 종료시키는 명령값 자체가 프로그램 내에서 변하면 그에 따라 조건이 변해야 하는 문제가 있으므로,</p><p>특정하게 값을 고정시켜 그 값을 이용해야 할 경우 사용할 수 있다.</p><p>(물론 위의 설명은 변수를 예를 들어 사용한 것이지만, 변수가 아닌 클래스 메소드에도 사용 가능하다)</p><p>혹시 몰라 부가적인 설명을 하나 더하자면,</p><ul><li>final 변수 : 상수 (값을 변경할 수 없음).</li><li>final 메소드 : 오버라이딩이 안되는 메소드</li><li>final 클래스 : 상속이 안되는 클래스 정도로 구분하면 될 듯 하다.</li></ul><p>final에 관한 내용을 더 이야기하자면 길어질 듯 하니 이건 여기서 그만;</p><p>이건 메소드를 실행한 결과 그 메소드에서 최종적으로 특정한 return 값이 없을 경우</p><p>return값이 없다라고 선언하는 명령어이다.</p><p>프로그램 안에서 메소드를 만든다는 것은 어떤 목적을 가지고 만들게 되는 것일텐데,</p><p>그 목적에 따라 return값이 있는 경우도 있고 없는 경우도 있을 것이다.</p><p>이게 무슨 의미이냐 하면,</p><p>값을 계산하고 그 값을 화면에 출력하고자 하는 계산기 프로그램을 만들고자 할 때,</p><p>특정 메소드에서 값을 입력하면 계산만 하게 하는 메소드를 만들 수도 있고</p><p>계산까지 하여 계산 된 값을 화면에 출력까지 하게 하는 메소드를 만들 수도 있다.</p><p>계산만 하게 하는 메소드를 만든다면</p><p>계산만 하는 메소드를 따로 만들고, 출력을 담당하는 메소드를 따로 만들어야 하는데,</p><p>계산만 하는 메소드에서 먼저 계산만을 담당하고 </p><p>출력을 담당하는 메소드에 그 값을 전달하여 화면에 출력을 시켜야 하는데,</p><p>계산 메소드 안에서 원하는 모든 프로세스(계산을 하여 출력)가 끝난 것이 아니라</p><p>그 값을 이용하여 출력 메소드에서 계산된 값을 사용 하려는 목적인 만큼</p><p>계산된 값을 return하여 그 계산된 값을 사용하려는 곳으로 전달하는 과정이 필요하게 되고,</p><p>이럴 경우 메소드를 선언할 경우 void 가 아닌 int, double, String 과 같은 다른 타입의 선언이 필요하다.</p><p>하지만 계산 메소드를 만들면서 그 안에다가 출력을 담당하는 내용까지 추가를 한다면,</p><p>내가 맨 처음 작성하고자 했던 계산 -&gt; 출력의 부분이 해당 메소드 안에 모두 들어가 있게 되므로써</p><p>메소드 안에서 계산 된 값이 다른 곳에서 사용 되는 것이 아닌</p><p>그 메소드 안에서 원하는 프로세스를 모두 완료시킨 것이 되므로</p><p>이럴 경우 return 값이 없으므로 이럴 경우 return 값이 없다라는 것을 알려주고자 void를 사용하게 된다.</p><p>출처 : <a href="https://blog.naver.com/crazydeicide/130114957734">https://blog.naver.com/crazydeicide/130114957734</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;public-static-void-main-String-args-메인의-의미는-무엇인가&quot;&gt;&lt;a href=&quot;#public-static-void-main-String-args-메인의-의미는-무엇인가&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jakezo.github.io/categories/JAVA/"/>
    
    
    <category term="Java" scheme="http://jakezo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 프로젝트 쇼핑몰 만들기</title>
    <link href="http://jakezo.github.io/2021/02/22/spring-project/"/>
    <id>http://jakezo.github.io/2021/02/22/spring-project/</id>
    <published>2021-02-22T03:46:28.000Z</published>
    <updated>2021-05-02T16:00:34.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로젝트소개"><a href="#프로젝트소개" class="headerlink" title="프로젝트소개"></a>프로젝트소개</h1><p>프로젝트를 위해 무엇을 해볼까 생각해 보다가, 실용적이고 많이 쓰이는 의류 쇼핑몰 사이트를 만들어 보았습니다. </p><p>기본적인 회원 기능과 관리자 기능을 넣어 만들어 보았습니다.</p><h1 id="메인-페이지"><a href="#메인-페이지" class="headerlink" title="메인 페이지"></a>메인 페이지</h1><img src="https://i.esdrop.com/d/aF3WTmz3IP.png"/><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><h2 id="테이블-구성도"><a href="#테이블-구성도" class="headerlink" title="테이블 구성도"></a>테이블 구성도</h2><img src="https://i.esdrop.com/d/mQf7zAzJl1.png"/><h2 id="테이블-관계도"><a href="#테이블-관계도" class="headerlink" title="테이블 관계도"></a>테이블 관계도</h2><img src="https://i.esdrop.com/d/0G0Kv33QYV.jpg"/><h1 id="프로젝트-구현과정"><a href="#프로젝트-구현과정" class="headerlink" title="프로젝트 구현과정"></a>프로젝트 구현과정</h1><h2 id="Member"><a href="#Member" class="headerlink" title="Member"></a>Member</h2><h3 id="MemberLoginCommand"><a href="#MemberLoginCommand" class="headerlink" title="MemberLoginCommand"></a>MemberLoginCommand</h3><pre><code class="java">public class MemberLoginCommand implements MemberCommand &#123;    @Override    public Map&lt;String, Object&gt; execute(SqlSession sqlSession, Model model) &#123;        Map&lt;String, Object&gt; map = model.asMap();        MemberDto memberDto = (MemberDto) map.get(&quot;memberDto&quot;);        HttpServletRequest request = (HttpServletRequest) map.get(&quot;request&quot;);        HttpSession session = request.getSession();        MemberDao memberDao = sqlSession.getMapper(MemberDao.class);        CartDao cartDao = sqlSession.getMapper(CartDao.class);        Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;();        String m_id = memberDto.getM_id();        String m_pw = Sha256.sha256(memberDto.getM_pw());        if (memberDao.login(m_id, m_pw) != null) &#123;            resultMap.put(&quot;loginResult&quot;, 1); // 로그인 성공            session.setAttribute(&quot;loginDto&quot;, memberDao.login(m_id, m_pw));            // 장바구니 개수            int m_no = memberDao.login(m_id, m_pw).getM_no();            session.setAttribute(&quot;crt_count&quot;, cartDao.cartCount(m_no));            // TEST 코드            System.out.println(&quot;로그인한 회원 DB: &quot; + memberDao.login(m_id, m_pw));        &#125; else if (memberDto.getM_id() == &quot;&quot;) &#123;            resultMap.put(&quot;loginResult&quot;, 0); // 아이디 항목 공백        &#125; else if (memberDto.getM_pw() == &quot;&quot;) &#123;            resultMap.put(&quot;loginResult&quot;, -1); // 패스워드 항목 공백        &#125; else if (memberDto.getM_pw().length() &lt; 8) &#123;            resultMap.put(&quot;loginResult&quot;, -2); // 패스워드 항목 8자 미만 입력        &#125; else &#123;            resultMap.put(&quot;loginResult&quot;, -3); // 아이디 패스워드 불일치        &#125;        return resultMap;    &#125;&#125;</code></pre><h3 id="loginPage-jsp"><a href="#loginPage-jsp" class="headerlink" title="loginPage.jsp"></a>loginPage.jsp</h3><pre><code class="java">function login() &#123;          var m_id = $(&#39;#m_id&#39;).val();        var m_pw = $(&#39;#m_pw&#39;).val();        var sendByIdPw = &#123;            &quot;m_id&quot; : m_id,            &quot;m_pw&quot; : m_pw        &#125;        $.ajax(&#123;            url: &#39;login.do&#39;,            type: &#39;post&#39;,            data: JSON.stringify(sendByIdPw),  // JSON -&gt; String 형변환 후 컨트롤러로 보내는 String 타입의 JSON 데이터            contentType: &#39;application/json&#39;,  // 컨트롤러로 보내는 데이터의 타입을 알려주기 위해            dataType: &#39;json&#39;,            success: function(responseObj) &#123;  // 성공하면 받아오는 데이터                if (responseObj.loginResult == 1) &#123;                    alert(m_id + &#39;님 환영합니다.&#39;)                    location.href = &#39;$&#123;referer&#125;&#39;;                &#125; else if (responseObj.loginResult == 0) &#123;                    alert(&#39;아이디 항목은 필수 입력값입니다.&#39;)                    $(&#39;#m_id&#39;).focus();                &#125; else if (responseObj.loginResult == -1) &#123;                    alert(&#39;패스워드 항목은 필수 입력값입니다.&#39;)                    $(&#39;#m_pw&#39;).focus();                &#125; else if (responseObj.loginResult == -2) &#123;                    alert(&#39;패스워드 항목이 8자(개) 이상으로 해주십시오.&#39;)                    $(&#39;#m_pw&#39;).focus();                &#125; else if (responseObj.loginResult == -3) &#123;                    alert(&#39;아이디 또는 비밀번호가 일치하지 않습니다.&#39;)                    $(&#39;#m_pw&#39;).focus();                    location.href=&#39;loginPage.do&#39;;                &#125; else &#123;                    alert(&#39;loginResult == null&#39;)                &#125;            &#125;,            error: function() &#123;                alert(&#39;AJAX FAIL&#39;)            &#125;        &#125;);      &#125;</code></pre><h3 id="로그인-화면"><a href="#로그인-화면" class="headerlink" title="로그인 화면"></a>로그인 화면</h3><img src="https://i.esdrop.com/d/YNHQb69kzC.png"/><hr><h3 id="비밀번호-찾기-인증요청메일"><a href="#비밀번호-찾기-인증요청메일" class="headerlink" title="비밀번호 찾기 인증요청메일"></a>비밀번호 찾기 인증요청메일</h3><img src="https://i.esdrop.com/d/I729lHCb93.png"/><hr><h2 id="PRODUCT"><a href="#PRODUCT" class="headerlink" title="PRODUCT"></a>PRODUCT</h2><p>기본적으로 로그인, 사이즈 선택 안하고 구매, 카트 누르면 알림<br>카트에 담기, 구매하기 클릭시<br>재고가 없는 경우 (옵션에 품절 표시됨) 및 알림 : 제이쿼리 사용<br>Ajax로 카트 현황 파악하여 중복 알림</p><img src="https://i.esdrop.com/d/8jjjRXlwJZ.png"/><blockquote><p>구성 </p></blockquote><p>사이즈 S와 free인 제품들만 프로덕트 리스트에 보여지므로<br>사이즈에 상관없이 카트나 오더, 리뷰에서 제품을 클릭했을 때 뷰 페이지 연결되도록 커맨드 작성</p><p>컨트롤러에 상품 아래 리뷰 페이지 연결되도록 리뷰 리스트 커맨드 추가</p><hr><h2 id="Cart"><a href="#Cart" class="headerlink" title="Cart"></a>Cart</h2><img src="https://i.esdrop.com/d/5yq520WRXb.png"/><p>카트 목록에서 수량 변경, 삭제, 주문 가능<br>수량변경은 ajax 사용<br>주문은 체크박스 선택해서 선택 주문하거나 전체주문 클릭해서 전체 주문 가능<br>Target에 제품번호를 넘겨서 이동하는데 전체 주문할 경우 target을 all로 임의로 설정해 카트에 있는 모든 제품을 불러옴</p><h2 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h2><img src="https://i.esdrop.com/d/ieNS0bgKkG.png"/><blockquote><p>구성 </p></blockquote><p>주소 api 다음에서 제공하는 api 사용하여 적용<br>결제 시 적립금 제이쿼리로 연결하여 실시간 적용<br>구매수량별 가격 계산<br>결제수단에 따라 내용 변경..<br>결제하기 누르면 해당 제품 재고 감소, 사용한 포인트 감소</p><img src="https://i.esdrop.com/d/DgKopmQpPr.png"/><blockquote><p>구성 </p></blockquote><p>주문조회에서 주문한 건 별로 리스트 출력<br>주문번호 클릭 시 주문 건에 대한 내용 조회<br>주문 취소가능<br>주문 취소하면 재고, 포인트 복구</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p><sub>search 부분 ajax</sub></p><pre><code class="java">$.ajax(&#123;            url : &#39;productSearch.do&#39;,            type : &#39;post&#39;,            data : JSON.stringify(obj),            contentType : &#39;application/json&#39;,            dataType : &#39;json&#39;,            success : function(responseObj) &#123;                $(&#39;#searchButton&#39;).empty();                $(&#39;#searchResult&#39;).empty();                $(&#39;#noData&#39;).empty();                $(&#39;&lt;strong&gt;&#39;).html(responseObj.search_count).appendTo(&#39;#searchResult&#39;);                if (responseObj.result) &#123;                    searchList(responseObj.list);                &#125; else &#123;                    $(&#39;&lt;strong&gt;&#39;)                    .html(&#39;검색결과가 없습니다&#39;)                    .append($(&#39;&lt;ul&gt;&#39;))                    .append($(&#39;&lt;li&gt;&#39;).html(&#39;검색어/제외검색어의 입력이 정확한지 확인해 보세요.&#39;))                    .append($(&#39;&lt;li&gt;&#39;).html(&#39;두 단어 이상의 검색어인 경우, 띄어쓰기를 확인해 보세요.&#39;))                    .append($(&#39;&lt;li&gt;&#39;).html(&#39;검색 옵션을 다시 확인해 보세요.&#39;))                    .appendTo(&#39;#noData&#39;);                &#125;                var paging = responseObj.paging;                $(&#39;#paging&#39;).empty();                if (paging.beginPage &lt;= paging.pagePerBlock) &#123;                    // class 의미                    // disable : css (클릭 안 되는 건 실버색) 적용하려고                    $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;disable&quot;&gt;&lt;a&gt;◀&lt;/a&gt;&lt;/div&gt;&#39;);                &#125; else &#123;                    // class 의미                    // 1) prev-block : 이전(◀)으로 이동하려고                    // 2) go-page : css (cursor: pointer) 적용하려고                    $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;prev-block go-page&quot; data-page=&quot;&#39; + (paging.beginPage - 1) + &#39;&quot;&gt;&lt;a&gt;◀&lt;/a&gt;&lt;/div&gt;&#39;);                &#125;                // 1 2 3 4 5                for (let p = paging.beginPage; p &lt;= paging.endPage; p++) &#123;                    if (paging.page == p) &#123; // 현재페이지는 링크가 안 됩니다.                        // class 의미                        // now-page : css (현재 페이지는 녹색) 적용하려고                        $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;now-page&quot;&gt;&lt;a&gt;&#39; + p + &#39;&lt;/a&gt;&lt;/div&gt;&#39;)                    &#125; else &#123;                        // class 의미                        // go-page : css (cursor: pointer) 적용하려고                        $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;go-page&quot; data-page=&quot;&#39; + p + &#39;&quot;&gt;&lt;a&gt;&#39; + p + &#39;&lt;/a&gt;&lt;/div&gt;&#39;);                    &#125;                &#125;                // ▶                if (paging.endPage &gt;= paging.totalPage) &#123;                    // class 의미                    // disable : css (클릭 안 되는 건 실버색) 적용하려고                    $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;disable&quot;&gt;&lt;a&gt;▶&lt;/a&gt;&lt;/div&gt;&#39;);                &#125; else &#123;                    // class 의미                    // 1) next-block : 다음(▶)으로 이동하려고                    // 2) go-page : css (cursor: pointer) 적용하려고                    $(&#39;#paging&#39;).append(&#39;&lt;div class=&quot;next-block go-page&quot; data-page=&quot;&#39; + (paging.endPage + 1) + &#39;&quot;&gt;&lt;a&gt;▶&lt;/a&gt;&lt;/div&gt;&#39;);                &#125;            &#125;,            error : function() &#123;                alert(&#39;AJAX FAIL&#39;);            &#125;        &#125;);</code></pre><p>위의 <code>if (responseObj.result) &#123;                     searchList(responseObj.list);</code> 이부분이</p><pre><code>아래부분으로  갑니다.</code></pre><pre><code class="java">    function searchList(list) &#123;        $.each(list, function(index, item) &#123;            var s_List = &quot;&quot;;            s_List += &#39;&lt;li id=&quot;anchorBoxId_212&quot; class=&quot;xans-record-&quot;&gt;&#39;;            s_List += &#39; &lt;div class=&quot;thumbnail&quot;&gt;&#39;;            s_List += &#39;&lt;a href=&quot;productViewPage.do?p_No=&#39; + item.p_No + &#39;&quot;&gt;&#39;;            s_List += &#39;&lt;img src=&quot;&#39; + item.p_Image + &#39;&quot;&gt;&lt;/a&gt;&lt;/div&gt;&#39;;            s_List += &#39;&lt;div class=&quot;description&quot;&gt;&#39;;            s_List += &#39;&lt;strong class=&quot;name&quot; style=&quot;font-weight:normal;text-align:left&quot;&gt;&#39;;            s_List += &#39;&lt;a href=&quot;productViewPage.do?p_No=&#39; + item.p_No + &#39;&quot;&gt;&#39;;            s_List += &#39;&lt;span class=&quot;title displaynone&quot;&gt;&lt;span style=&quot;font-size:12px;color:#000000;&quot;&gt;상품명&lt;/span&gt; &lt;/span&gt;&#39;;            s_List += &#39;&lt;span style=&quot;font-size:12px;color:#000000;&quot;&gt;&#39; + item.p_Name + &#39;[&#39; + item.p_Color + &#39;]&#39; + &#39;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&#39;;            s_List += &#39;&lt;ul class=&quot;xans-element- xans-search xans-search-listitem spec&quot;&gt;&lt;li class=&quot; xans-record-&quot;&gt;&#39;;            s_List += &#39;&lt;strong class=&quot;title displaynone&quot;&gt;&lt;span style=&quot;font-size:12px;color:#000000;&quot;&gt;판매가&lt;/span&gt; &lt;/strong&gt;&#39;;            s_List += &#39;&lt;span style=&quot;font-size:12px;color:#000000;&quot;&gt;₩&#39; + item.p_Price + &#39;&lt;/span&gt;&lt;span id=&quot;span_product_tax_type_text&quot; style=&quot;&quot;&gt; &lt;/span&gt;&lt;/li&gt;&#39;;            s_List += &#39;&lt;/ul&gt; &lt;/li&gt;&#39;;            var $searchButton = $(&quot;#searchButton&quot;);            $searchButton.append(s_List);        &#125;);    &#125;</code></pre><p>ajax로 값을 받아온후  result값이 true면 searchList를 불러옵니다</p><h3 id="상품-정렬기준-설정"><a href="#상품-정렬기준-설정" class="headerlink" title="상품 정렬기준 설정"></a>상품 정렬기준 설정</h3><img src="https://i.esdrop.com/d/FY6TmBvc9i.png"/><p>검색어와 선택한 option의 값이 모두 일치할때 나타나는 list 값이 달라집니다</p><h3 id="Search-버튼-누른-이후-구성"><a href="#Search-버튼-누른-이후-구성" class="headerlink" title="Search 버튼  누른 이후 구성"></a>Search 버튼  누른 이후 구성</h3><img src="https://i.esdrop.com/d/LDmyZ4qZaK.png"/><p>option 과 검색어 입력까지 완료후 search 버튼을 누르면 list 가 나타납니다<br>command에서 받아온 list의 갯수를 받아오는 search_count값을 입력하여 총 갯수를 나타내줍니다</p><h3 id="페이징-처리"><a href="#페이징-처리" class="headerlink" title="페이징 처리"></a>페이징 처리</h3><img src="https://i.esdrop.com/d/d2QqSh62I6.png"/><hr><h2 id="Boards"><a href="#Boards" class="headerlink" title="Boards"></a>Boards</h2><blockquote><p>1 </p></blockquote><img src="https://i.esdrop.com/d/fVuE17aAjv.png"/><ul><li>작성페이지는 EDITOR를 사용하여 CONTENT에 설정을 넣을 수 있도록 하였습니다.</li><li>EDITOR는 CSS부분과 JS부분으로 나눌수있는데 CSS부분은 기본을 그대로 사용하였고, JS부분만 내용을 가져왔습니다. </li><li>탬플릿과 같은 구성이기에 각주가 걸려있는부분과, 아래의 완료버튼과 연결되어있는 click function만 수정하면 손쉽게 사용할 수 있습니다.</li><li>또한 첨부를 다중첨부를 할 수 있도록 구현하였고, 이미지일 경우 이미지를 작성된 게시물에 자동으로 보여지게끔 구현하였습니다.</li><li>완료버튼 클릭 시 게시물이 작성되고 게시판의 가장 첫페이지로 넘어가게되며, 목록보기로 넘어갈경우 기존에 게시물 작성을 누르기전의 페이지를 기억하여 그곳으로 넘어갑니다.</li></ul><blockquote><p>2</p></blockquote><img src="https://i.esdrop.com/d/2ADl3OASXL.png"/><ul><li>작성페이지는 EDITOR를 사용하여 CONTENT에 설정을 넣을 수 있도록 하였습니다.</li><li>EDITOR는 CSS부분과 JS부분으로 나눌수있는데 CSS부분은 기본을 그대로 사용하였고, JS부분만 내용을 가져왔습니다.</li><li>탬플릿과 같은 구성이기에 각주가 걸려있는부분과, 아래의 완료버튼과 연결되어있는 click function만 수정하면 손쉽게 사용할 수 있습니다.</li><li>또한 첨부를 다중첨부를 할 수 있도록 구현하였고, 이미지일 경우 이미지를 작성된 게시물에 자동으로 보여지게끔 구현하였습니다.</li><li>완료버튼 클릭 시 게시물이 작성되고 게시판의 가장 첫페이지로 넘어가게되며, 목록보기로 넘어갈경우 기존에 게시물 작성을 누르기전의 페이지를 기억하여 그곳으로 넘어갑니다.</li></ul><blockquote><p>3</p></blockquote><ul><li><p>댓글과 대댓글의 작성은 게시물 고유번호와 댓글의 순번, 그리고 대댓글의 일련번호로 로직이 이루어져있습니다.</p></li><li><p>댓글의 수정과 삭제는 ajax를 이용하지않고 게시판의 수정과 삭제와 동일한 방식으로 되지만, 구현되는 페이지상에서는 동기식처럼 구현이 되도록 jquery와 js를 사용하였습니다.</p></li><li><p>토글(checkbox)을 이용해 댓글의 수정 혹은 대댓글 작성을 버튼의 클릭에 따라 조정되도록 구현하였습니다.</p></li></ul><img src="https://i.esdrop.com/d/KugUqIFqPW.png"/><blockquote><p>4</p></blockquote><ul><li><p>게시물의 수정은 기본적으로 게시물작성과 동일한 상태로 작성된 데이터들만을 가져오는 방식으로 되어있습니다.</p></li><li><p>모든부분이 동일하지만,<br>수정되는 첨부파일은 기존에 가지고있던 첨부파일이름을 새 첨부파일로 전부 덮어쓰기하는 방식으로 진행이되었습니다.</p></li><li><p>삭제는 기본적인 구성을 하고있습니다만, 작성게시물의 첨부와, 댓글은 유지하지않고 모두 선삭제후 게시물이 삭제되도록 구현되어있습니다.</p></li></ul><img src="https://i.esdrop.com/d/RT0zdvjmym.png"/><blockquote><p>5</p></blockquote><ul><li>QNA와 리뷰게시판의경우 추가적인 기능이있습니다.<br>품목선택 기능과 비밀글기능이 바로 그것인데 품목선택의경우 게시판에서 작성이라면, 주문을한 제품에 대해서만 작성을 할 수 있게끔 되어있습니다. </li><li>비밀글의경우 체크가 기본으로 되어있으며 체크시 비밀번호를 작성할수있고, 비밀글로 작성된글은 자물쇠표시가 달리게됩니다.</li><li>로그인한사람과 글쓴이가 동일하다면 바로 view페이지로 넘어가게되며, 아닐경우엔 password입력페이지로 넘어가게됩니다.</li></ul><img src="https://i.esdrop.com/d/oI9rBYZ1uD.png"/><h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><img src="https://i.esdrop.com/d/krHancTd8o.png"/><img src="https://i.esdrop.com/d/zQUng1OfE4.png"/><p>admin 에서는 관리자 라는 아이디로 접속 할 경우에만 위에 Admin 버튼이 생기고 회원 관리를 할 수 있게 만들었습니다 </p><p><sub>관리자 아이디: admin1 </sub> </p><p><sub>관리자 비밀번호: 1q2w3e4r<br></sub></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;프로젝트소개&quot;&gt;&lt;a href=&quot;#프로젝트소개&quot; class=&quot;headerlink&quot; title=&quot;프로젝트소개&quot;&gt;&lt;/a&gt;프로젝트소개&lt;/h1&gt;&lt;p&gt;프로젝트를 위해 무엇을 해볼까 생각해 보다가, 실용적이고 많이 쓰이는 의류 쇼핑몰 사이트를 만들어</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="project" scheme="http://jakezo.github.io/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>EL/JSTL</title>
    <link href="http://jakezo.github.io/2021/01/24/EL-JSTL/"/>
    <id>http://jakezo.github.io/2021/01/24/EL-JSTL/</id>
    <published>2021-01-24T06:16:47.000Z</published>
    <updated>2021-01-24T06:49:38.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EL-JSTL-정리"><a href="#EL-JSTL-정리" class="headerlink" title="EL / JSTL 정리"></a>EL / JSTL 정리</h2><p>JSP파일에 자바형식의 코드를 사용하면 불편한 점을 한방에 해결할 수 있는 EL (Expression Language) 과 JSTL (Jsp Standard Tag Library)를 이용해 코드를 간결하게 사용하는 방법에 대해 포스팅하도록 하겠습니다. </p><p>EL의 개념은 해석 그대로 표현 언어를 이해하고 속성 값들을 편리하게 출력하기 위해 제공된 언어이며, JSTL은 표준 액션태그로 처리하기 힘든 부분을 담당합니다. </p><p>JSP 2.0버전에서 새로 추가된 스크립트 언어인 <mark>EL(Expression Language)</mark>은 <strong>&lt;%= abc %&gt;</strong>를 <code>$&#123;abc&#125;</code>로 간단하게 사용할 수 있게 하였고, JSTL의 Core에서 c를 이용해 <strong>&lt;%= if%&gt;</strong>문을 <code>&lt;c:if&gt;</code>, <strong>&lt;%=for%&gt;</strong>문을 <code>&lt;c:forEach&gt;</code>로 대체하여 사용합니다. 그럼 따로따로 살펴보도록 하겠습니다. 둘을 같이 묶어서 포스팅하는 이유는 제 게시판 프로젝트에 같이 사용되기 때문입니다.</p><hr><h3 id="EL-Expression-Language"><a href="#EL-Expression-Language" class="headerlink" title="EL (Expression Language)"></a>EL (Expression Language)</h3><blockquote><p>▼ 사용목적</p></blockquote><p>&lt;%= %&gt; , out.println()과 같은 자바코드를 </p><p>더 이상 사용하지 않고 좀더 간편하게 출력을 지원하기 위한 도구.</p><p>배열이나 컬렉션에서도 사용되고, JavaBean의 프로퍼티에서도 사용됩니다.</p><blockquote><p>▼ 문법</p></blockquote><p>Attribute형식에서는 &lt;%= cnt + 1 %&gt;를 쓰지 않고 ${cnt + 1}로 쓰고</p><p>Parameter형식에서는 ${param.abc}으로 씁니다.</p><p>여기서 cnt는 자바에서는 변수 이름이고, EL 식에서는 Attribute의 이름으로 해석되는데요. </p><p>값을 찾을때 Attribute는 작은 Scope에서 큰 Scope로 찾습니다.</p><p>(page → request → session → application)</p><table><thead><tr><th><code>[ attribute란? : 메소드를 통해 저장되고 관리되는 데이터 ]</code></th></tr></thead><tbody><tr><td><mark>PageContext / Request에서 사용될때</td></tr><tr><td>setAttribute(“key”, value) → 값을 넣는다.</td></tr><tr><td>getAttribute(“key”) → 값을 가져온다.</td></tr><tr><td>removeAttribue(“key”) → 값을 지운다.</td></tr><tr><td><mark>session에서 사용될때</td></tr><tr><td>set / get / remove 동일하고 추가로++</td></tr><tr><td>invalidate( ) → 값을 전부 지운다.</td></tr></tbody></table><blockquote><p>EL</p></blockquote><ol><li><p>Expression Language (표현언어)</p></li><li><p>JSP의 새로운 스크립트 언어</p></li><li><p>기존의 표현식(&lt;%=표현식%&gt;을 대체하는 역할</p></li><li><p>대체방식<br> &lt;%=표현식%&gt; &gt; $ {표현언어}</p></li><li><p>데이터를 저장할 수 있는 4개 영역에서 사용할 수 있다.</p><ol><li>pageContext</li><li>request</li><li>session</li><li>application</li></ol></li><li><p>각 영역의 우선순위<br> pageContext &gt; request &gt; session &gt; application</p></li><li><p>각 영역의 스코프 키워드</p><ol><li>pageContext: pageScope</li><li>request: requestScope</li><li>session: sessionScope</li><li>application: applicationScope</li></ol></li><li><p>저장이 “속성”으로 된 경우 다음과 같이 사용한다</p><ol><li>pageContext.setAttribute(“name”, “에밀리”) &gt; ${name} &gt; ${pageScope.name}</li><li>request.setAttribute(“age”, 25) &gt; $ {age} &gt; $ {requestScope.age}</li></ol></li><li><p>request에 파라미터로 저장된 경우 다음과 같이 사용<br> 문자열</p><ol><li><code>&lt;input type=&quot;text&quot; name=&quot;id&quot; /&gt;</code> -&gt; ${param.id}    // parameter의 줄임말<br>배열</li><li><code>&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; /&gt;</code> -&gt; ${paramValues.honbbies[0]}<br> <code>&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; /&gt;</code> -&gt; ${paramValues.honbbies[1]}</li></ol></li><li><p>EL 연산자</p><ol><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li>/, div                 : 나누기</li><li>%, mod                 : 나머지</li><li><code>&gt;</code>, gt(greater than)     : 크다</li><li><code>&gt;=</code>, ge(greater equal) : 크거나 같다</li><li><code>&lt;</code>, lt(less than)         : 작다</li><li>&lt;=, le(less equal)     : 작거나 같다</li><li>==, eq(equal)          : 같다</li><li>!=, ne(not equal)       : 같지 않다</li><li>and                     : 그리고</li><li>or                     : 또는</li><li>not                  : 부정</li><li>empty                  : 비어 있다</li></ol></li></ol><h3 id="1-JSTL이란"><a href="#1-JSTL이란" class="headerlink" title="1. JSTL이란?"></a>1. JSTL이란?</h3><p>일반적으로 알고있는 JSTL이란 <strong>JSTL + EL</strong>의 조합을 말한다.</p><p>HTML 코드 내에 java 코드인 스크립틀릿 <code>&lt;%= student %&gt;</code>를 <code>$&#123;student&#125;</code>로, <code>&lt;%=if %&gt;</code>문을 <code>&lt;c:if&gt;</code>, <code>&lt;%=for%&gt;</code>문을 <code>&lt;c:forEach&gt;</code>로 대체하여 사용한다.</p><p>예전에는 스크립틀릿을 많이 사용했지만 가독성이 떨어지고, 뷰와 비즈니스로직의 분리로 인해 현재는 JSTL을 많이 사용하는 추세다. JSTL과 EL은 보통 함께 사용하는데 그 이유와 각각의 개념, 각각의 차이와 문법을 정리해보도록 하자.</p><h3 id="2-JSTL"><a href="#2-JSTL" class="headerlink" title="2. JSTL"></a>2. JSTL</h3><p>JSTL의 정식 명칭은 <strong>자바서버 페이지 표준 태그 라이브러리</strong>(JavaServer Pages Standard Tag Library)이고 줄여서 JSTL이라 부른다.</p><p><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EC%84%9C%EB%B2%84_%ED%8E%98%EC%9D%B4%EC%A7%80_%ED%91%9C%EC%A4%80_%ED%83%9C%EA%B7%B8_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC">위키피디아</a>를 참조하자면, JSTL은 Java EE 기반의 웹 애플리케이션 개발 플랫폼을 위한 컴포넌트 모음이다. JSTL은 XML 데이터 처리와 조건문, 반복문, 국제화와 지역화와 같은 일을 처리하기 위한 JSP 태그 라이브러리를 추가하여 JSP 사양을 확장했다.</p><p>JSTL은 JSP 페이지 내에서 자바 코드를 바로 사용하지 않고 로직을 내장하는 효율적인 방법을 제공한다. 표준화된 태그 셋을 사용하여 자바 코드가 들락거리는 것보다 더 코드의 유지보수와 응용 소프트웨어 코드와 사용자 인터페이스 간의 관심사의 분리로 이어지게 한다.</p><h5 id="JSTL의-사용법"><a href="#JSTL의-사용법" class="headerlink" title="JSTL의 사용법"></a>JSTL의 사용법</h5><p>JSTL은 라이브러리이기 때문에 사용하기전에 core를 header에 추가해주어야 한다.</p><pre><code class="html">&lt;% @taglib uri=&quot;http://java.sun.com/jstl/core&quot; prefix=&quot;c&quot; %&gt;</code></pre><p>사용방법은 다음과 같다.</p><pre><code class="html">&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;&lt;c:forEach items=&quot;&quot;&gt;&lt;/c:forEach&gt;</code></pre><h5 id="JSTL-core의-태그들"><a href="#JSTL-core의-태그들" class="headerlink" title="JSTL core의 태그들"></a>JSTL core의 태그들</h5><table><thead><tr><th>태그명</th><th>설명</th></tr></thead><tbody><tr><td>&lt;c:set&gt;</td><td>변수명에 값을 할당</td></tr><tr><td>&lt;c:out&gt;</td><td>값을 출력</td></tr><tr><td>&lt;c:if&gt;</td><td>조건식에 해당하는 블럭과 사용될 scope설정</td></tr><tr><td>&lt;c:choose&gt;</td><td>다른 언어의 switch와 비슷</td></tr><tr><td>&lt;c:when&gt;</td><td>switch문의 case에 해당</td></tr><tr><td>&lt;c:otherwise&gt;</td><td>switch문의 default에 해당</td></tr><tr><td>&lt;c:forEach&gt;</td><td>다른언어의 loop문 items 속성에 배열을 할당할 수 있음</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;EL-JSTL-정리&quot;&gt;&lt;a href=&quot;#EL-JSTL-정리&quot; class=&quot;headerlink&quot; title=&quot;EL / JSTL 정리&quot;&gt;&lt;/a&gt;EL / JSTL 정리&lt;/h2&gt;&lt;p&gt;JSP파일에 자바형식의 코드를 사용하면 불편한 점을 한방에 해</summary>
      
    
    
    
    <category term="JAVA-WEB" scheme="http://jakezo.github.io/categories/JAVA-WEB/"/>
    
    <category term="API" scheme="http://jakezo.github.io/categories/JAVA-WEB/API/"/>
    
    
    <category term="JSP" scheme="http://jakezo.github.io/tags/JSP/"/>
    
    <category term="JSTL" scheme="http://jakezo.github.io/tags/JSTL/"/>
    
    <category term="EL" scheme="http://jakezo.github.io/tags/EL/"/>
    
  </entry>
  
  <entry>
    <title>spring-Webmaker03</title>
    <link href="http://jakezo.github.io/2021/01/20/spring-Webmaker03/"/>
    <id>http://jakezo.github.io/2021/01/20/spring-Webmaker03/</id>
    <published>2021-01-20T02:48:23.000Z</published>
    <updated>2021-02-26T09:20:53.268Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="html">        &lt;div class=&quot;op-pay-method&quot;&gt;            &lt;h6&gt;결제수단&lt;/h6&gt;            &lt;div class=&quot;pay-area&quot;&gt;                &lt;div class=&quot;payment-choice&quot;&gt;                    &lt;input type=&quot;radio&quot; name=&quot;payment&quot; id=&quot;card&quot; value=&quot;1&quot; checked/&gt;카드결제                    &lt;input type=&quot;radio&quot; name=&quot;payment&quot; id=&quot;deposit&quot; value=&quot;2&quot;/&gt;무통장입금                &lt;/div&gt;                &lt;div class=&quot;payment-choice-result&quot;&gt;                    &lt;div class=&quot;left&quot;&gt;                        &lt;div class=&quot;payment-card&quot;&gt;                            &lt;div class=&quot;card-div&quot;&gt;                                &lt;p&gt;최소 결제 가능 금액은 결제금액에서 배송비를 제외한 금액입니다.&lt;/p&gt;                                &lt;p&gt;소액 결제의 경우 PG사 정책에 따라 결제 금액 제한이 있을 수 있습니다.&lt;/p&gt;                            &lt;/div&gt;                        &lt;/div&gt;                        &lt;div class=&quot;payment-deposit&quot;&gt;                            &lt;table class=&quot;deposit-info&quot;&gt;                                &lt;tbody&gt;                                    &lt;tr&gt;                                        &lt;td&gt;입금자명&lt;/td&gt;                                        &lt;td&gt;                                            &lt;input type=&quot;text&quot; name=&quot;deposit_name&quot; id=&quot;deposit_name&quot;/&gt;                                        &lt;/td&gt;                                    &lt;/tr&gt;                                    &lt;tr&gt;                                        &lt;td&gt;입금은행&lt;/td&gt;                                        &lt;td&gt;                                            &lt;select id=&quot;bankaccount&quot; name=&quot;bankaccount&quot;&gt;                                                &lt;option value=&quot;-1&quot;&gt;::: 선택해 주세요 :::&lt;/option&gt;                                                &lt;option value=&quot;1&quot;&gt;신한은행:110-123-12345 김사장&lt;/option&gt;                                            &lt;/select&gt;                                                          &lt;/td&gt;                                    &lt;/tr&gt;                                &lt;/tbody&gt;                            &lt;/table&gt;                            &lt;p&gt;최소 결제 가능 금액은 결제금액에서 배송비를 제외한 금액입니다&lt;/p&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;right&quot;&gt;                        &lt;table class=&quot;pay-info&quot;&gt;                            &lt;tr&gt;                                &lt;td colspan=&quot;2&quot; id=&quot;bor&quot;&gt;                                    &lt;span class=&quot;payment-card&quot;&gt;카드결제&lt;/span&gt;                                    &lt;span class=&quot;payment-deposit&quot;&gt;무통장입금&lt;/span&gt;                                    최종 금액                                &lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td colspan=&quot;2&quot; id=&quot;bor&quot;&gt;                                    &lt;span&gt;&amp;#8361;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pst_Price&quot;&gt;&lt;/span&gt;                                &lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td colspan=&quot;2&quot;&gt;                                    &lt;span class=&quot;payment-deposit&quot;&gt;                                &lt;input type=&quot;checkbox&quot; name=&quot;payment-agree&quot; id=&quot;payment-agree&quot; value=&quot;agree&quot;/&gt; 결제정보를 확인하였으며, 구매진행에 동의합니다.                                        &lt;/span&gt;                                &lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td colspan=&quot;2&quot;&gt;                                    &lt;input type=&quot;hidden&quot; name=&quot;prodPoint&quot; id=&quot;prodPoint&quot; value=&quot;&quot;/&gt;                                    &lt;input type=&quot;hidden&quot; name=&quot;o_price&quot; id=&quot;o_price&quot; value=&quot;&quot;/&gt;                                    &lt;input type=&quot;hidden&quot; name=&quot;m_no&quot; value=&quot;$&#123;memberDto.m_no&#125;&quot;/&gt;                                    &lt;input type=&quot;hidden&quot; name=&quot;p_No&quot; value=&quot;$&#123;productDto.p_No&#125;&quot;/&gt;                                    &lt;a href=&quot;#none&quot; class=&quot;pay&quot; onclick=&quot;fn_pay(this.form)&quot;&gt;&lt;img src=&quot;https://i.esdrop.com/d/Shc4pbWezP.gif&quot; alt=&quot;결제하기&quot; /&gt;&lt;/a&gt;                                    &lt;!-- &lt;input type=&quot;button&quot; class=&quot;pay&quot; value=&quot;결제하기&quot; onclick=&quot;fn_pay(this.form)&quot;/&gt; --&gt;                                &lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td&gt;총 적립예정금액&lt;/td&gt;                                &lt;td&gt;&lt;span class=&quot;point&quot;&gt;&lt;/span&gt;원&lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td&gt;상품별 구매적립금&lt;/td&gt;                                &lt;td&gt;                                    &lt;fmt:formatNumber value=&quot;$&#123;productDto.p_Price * 0.005&#125;&quot; pattern=&quot;#,##0&quot; /&gt;원                                &lt;/td&gt;                            &lt;/tr&gt;                            &lt;tr&gt;                                &lt;td&gt;회원 구매적립금&lt;/td&gt;                                &lt;td&gt;&lt;span class=&quot;inputPoint&quot;&gt;&lt;/span&gt;원&lt;/td&gt;                            &lt;/tr&gt;                        &lt;/table&gt;                    &lt;/div&gt;                 &lt;/div&gt;             &lt;/div&gt;         &lt;/div&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;

        &amp;lt;div class=&amp;quot;op-pay-method&amp;quot;&amp;gt;
            &amp;lt;h6&amp;gt;결제수단&amp;lt;/h6&amp;gt;
            &amp;lt;div clas</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="board" scheme="http://jakezo.github.io/tags/board/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 프로젝트의 기본 구조와 실행 순서</title>
    <link href="http://jakezo.github.io/2021/01/18/spring-sequence/"/>
    <id>http://jakezo.github.io/2021/01/18/spring-sequence/</id>
    <published>2021-01-18T03:46:28.000Z</published>
    <updated>2021-04-30T09:12:33.607Z</updated>
    
    <content type="html"><![CDATA[<p><sub> Spring MVC의 동작 순서에 대해 좀 더 명확히 파악 할 수 있도록 포스트를 남겨봅니다. </sub></p><h2 id="Spring-MVC-프로젝트의-기본-구조"><a href="#Spring-MVC-프로젝트의-기본-구조" class="headerlink" title="Spring MVC 프로젝트의 기본 구조"></a>Spring MVC 프로젝트의 기본 구조</h2><img src="https://i.esdrop.com/d/1FGfKAttbj.png"/><h2 id="Spring의-전체적인-실행-순서"><a href="#Spring의-전체적인-실행-순서" class="headerlink" title="Spring의 전체적인 실행 순서"></a>Spring의 전체적인 실행 순서</h2><p>Request -&gt; <strong>DispatcherServlet</strong> -&gt; <strong>HandlerMapping</strong> -&gt; (Controller -&gt; Service -&gt; DAO -&gt; DB -&gt; DAO -&gt; Service -&gt; Controller) -&gt; <strong>DispatcherServlet</strong> -&gt; <strong>ViewResolver</strong> -&gt; <strong>View</strong> -&gt; <strong>DispatcherServlet</strong> -&gt; Response</p><blockquote><p>예시 1. 일반적인 기본 동작 순서</p></blockquote><img src="https://i.esdrop.com/d/nP8IcR4VoT.png"/><blockquote><p>예시 2. 위 예시에서 Controller 뒷부분의 과정을 생략함</p></blockquote><img src="https://i.esdrop.com/d/ZMw2ZgeOk7.png"/><blockquote><p>자세한 스프링 실행 순서</p></blockquote><ol><li><p>클라이언트가 Request 요청을 하면, <code>DispatcherServlet</code>이 요청을 가로챈다. 이 때 DispatcherServlet이 모든 요청을 가로채는 건 아니고 web.xml에 등록된 내용만 가로챈다. 최초의 web.xml 에서는 <url-pattern>이 ‘/‘와 같이 해당 애플리케이션의 모든 URL로 등록돼있기 때문에, 만약 *. do와 같이 특정 URL만 적용하고 싶다면 <url-pattern>의 내용을 바꿔주어 범위를 변경하면 된다.</p></li><li><p>DispatcherServlet이 가로챈 요청을 <code>HandlerMapping</code>에게 보내 해당 요청을 처리할 수 있는 Controller를 찾는다.</p></li><li><p>실제 로직 처리 (Controller -&gt; Service -&gt; DAO -&gt; DB -&gt; DAO -&gt; Service -&gt; Controller)</p></li><li><p>로직 처리 후 <code>ViewResolver</code>를 통해 view 화면을 찾는다.</p></li><li><p>찾은 view 화면을 <code>View</code>에 보내면 이 결과를 다시 <code>DispatcherServlet</code>에 보내고, DispatcherServlet는 최종 클라이언트에게 전송한다.</p></li></ol><h3 id="web-xml-설정-파일"><a href="#web-xml-설정-파일" class="headerlink" title="web.xml 설정 파일"></a>web.xml 설정 파일</h3><p><sub>web.xml은 WAS가 최초 구동될 때 WEB-INF 디렉토리에 존재하는 web.xml을 읽고, 그에 해당하는 웹 애플리케이션 설정을 구성한다. 한마디로 각종 설정을 위한 설정파일이다.</sub></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/root-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Processes application requests --&gt; &lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><blockquote><p>각 태그를 세부적으로 살펴 보자.</p></blockquote><ul><li><code>&lt;servlet&gt;</code> : DispatcherServlet을 구현하기 위해 어떤 클래스를 이용해야 할지와 초기 파라미터 정보를 포함하고 있다. </li><li><code>&lt;servlet-name&gt;</code> : 해당 서블렛의 이름을 지정하면 이 지정된 이름을 가지고 다른 설정 파일에서 해당 서블릿 정보를 참조한다. </li><li><code>&lt;servlet-class&gt;</code> : 어떤 클래스를 가지고 DispatcherServlet을 구현할 것인지를 명시하고 있다. </li><li><code>&lt;init-param&gt;</code>  : 초기화 파라미터에 대한 정보. servlet에 대한 설정 정보가 여기에 들어간다. 만약 초기화 파라미터에 대한 정보를 기술하지 않을 경우 스프링이 자동적으로 appServlet-context.xml을 이용하여 스프링 컨테이너를 생성한다. </li><li><code>&lt;load-on-startup&gt;</code> :  서블릿이 로딩될 때 로딩 순서를 결정하는 값. 톰캣이 구동되고 서블릿이 로딩되기 전 해당 서블릿에 요청이 들어오면 서블릿이 구동되기 전까지 기다려야 한다. 이 중 우선순위가 높은 서블릿부터 구동할 때 쓰이는 값이다.</li><li><code>&lt;servlet-mapping&gt;</code> : 서블렛이 <code>&lt;url-pattern&gt;</code>에서 지정한 패턴으로 클라이언트 요청이 들어오면 해당 <code>&lt;servlet-name&gt;</code>을 가진 servlet에게 이 요청을 토스하는 정보를 기술한다. </li></ul><h3 id="root-context-xml-설정-파일"><a href="#root-context-xml-설정-파일" class="headerlink" title="root-context.xml 설정 파일"></a>root-context.xml 설정 파일</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- Root Context: defines shared resources visible to all other web components --&gt;&lt;/beans&gt;</code></pre><h3 id="servlet-context-xml-설정-파일"><a href="#servlet-context-xml-설정-파일" class="headerlink" title="servlet-context.xml 설정 파일"></a>servlet-context.xml 설정 파일</h3><p>servlet-context는 서블릿 관련 설정이다. 여기서 주목해야 하는 부분은 prefix와 suffix 부분이다. 서블릿 설정으로 prefix(접두사)와 suffix(접미사)를 붙여주는 역할을 담당한다. 즉, 우리가 일일이 전체경로와 .jsp를 붙이지 않아도 되도록 도와준다.</p><p>그다음으로 <code>&lt;context:component-scan base-package=&quot;com.company.first&quot; /&gt;</code> 부분을 보자. 이 부분은 스프링에서 사용하는 bean을 일일이 xml에 선언하지 않고도 필요한 것을 어노테이션(Annotation)을 자동으로 인식하게 하는 역할을 한다.</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- DispatcherServlet Context: defines this servlet&#39;s request-processing infrastructure --&gt; &lt;!-- Enables the Spring MVC @Controller programming model --&gt; &lt;annotation-driven /&gt; &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the $&#123;webappRoot&#125;/resources directory --&gt; &lt;resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt; &lt;!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory --&gt; &lt;beans:bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;beans:property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;beans:property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/beans:bean&gt; &lt;context:component-scan base-package=&quot;com.company.devpad&quot; /&gt;&lt;/beans:beans&gt;</code></pre><p>각 태그를 세부적으로 살펴보자.</p><ul><li><code>&lt;annotation-driven&gt;</code> : @Controller 어노테이션을 감지하여 해당 클래스를 Controller로 등록할 수 있도록 해주는 태그 </li><li><code>&lt;resources&gt;</code> : 정적인 html문서 같은 웹 리소스들의 정보를 기술하는 태그 </li><li><code>&lt;beans:bean class=&quot;org.springframework.web.servlet.view.InternalResourceBiewResolver&quot;&gt;</code> : Controller가 Model를 리턴하고 DispatcherServlet이 jsp 파일을 찾을 때 쓰이는 정보를 기술하는 태그. “home”이라는 문자열을 반환하면 /WEB-INF/views/ 경로에서 접미사가 .jsp인 해당 파일을 찾는다. /WEB-INF/views/home.jsp </li><li><code>&lt;context:component-scan&gt;</code> : Java 파일의 @Component로 등록된 Bean 객체를 찾도록 해주는 태그 </li></ul><hr><h3 id="자바-컨트롤러-파일-Java-Controller-File"><a href="#자바-컨트롤러-파일-Java-Controller-File" class="headerlink" title="자바 컨트롤러 파일(Java Controller File)"></a>자바 컨트롤러 파일(Java Controller File)</h3><blockquote><p>HomeController.java</p></blockquote><pre><code class="java">package com.company.devpad;import java.text.DateFormat; ...@Controllerpublic class HomeController &#123;    private static final Logger logger = LoggerFactory.getLogger(HomeController.class);    @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)    public String home(Locale locale, Model model) &#123;        logger.info(&quot;Welcome home! The client locale is &#123;&#125;.&quot;, locale);        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);        String formattedDate = dateFormat.format(date);        model.addAttribute(&quot;serverTime&quot;, formattedDate);        return &quot;home&quot;;    &#125;&#125;</code></pre><p><code>@Controller</code> : 어노테이션을 붙이면 servlet-context.xml에서 이것을 인식하여 컨트롤러로 등록함.</p><p><code>@RequestMapping</code> : 스프링은 HandlerMppaing에 의해 컨트롤러가 결정된다. 이 컨트롤러에서 HandlerAdapter에 의해 실행 메서드가 결정되는 데 @RequestMapping 어노테이션이 그 정보를 제공해 준다. value에 해당하는 url이 GET 방식으로 요청이 들어올 때 해당 메서드를 실행한다.</p><p>home 메서드는 serverTime이라는 속성을 Model에 추가하고 이 값은 formattedDate 변수 안에 담긴 현재 날짜 정보를 담고 있다. 이 정보는 JSP에서 클라이언트에게 전달할 HTML 문서를 만들 때 쓰인다. 여기서 모델은 어떤 구조화된 데이터를 담는 객체라고 보면 된다.</p><p>마지막으로 “home” 문자열을 반환하는 데 이 문자열은 나중에 servlet-context.xml에 설정된 prefix와 suffix 정보를 참조하여 /WEB-INF/views/home.jsp 파일을 찾는 정보를 제공한다.</p><h3 id="JSP-파일-JSP-Java-Server-Page-File"><a href="#JSP-파일-JSP-Java-Server-Page-File" class="headerlink" title="JSP 파일(JSP - Java Server Page File)"></a>JSP 파일(JSP - Java Server Page File)</h3><blockquote><p>home.jsp</p></blockquote><pre><code class="java">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ page session=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Home&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    Hello world!  &lt;/h1&gt;&lt;P&gt;  The time on the server is $&#123;serverTime&#125;. &lt;/P&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>JSP 파일은 Model 객체를 넘겨받고 그 Model 객체 안의 속성 값들의 정보를 ${} 기호에 표현된 부분에 치환한다. 예로 들어 ${serverTime}은 Model에서 addAttribute 메서드를 통해 추가했던 serverTime 정보인 현재 날짜를 담고 있다.</p><img src="https://i.esdrop.com/d/coTOl3oHJA.jpg"/><blockquote><p>References</p></blockquote><p><a href="https://javannspring.tistory.com/231">https://javannspring.tistory.com/231</a><br><a href="https://engkimbs.tistory.com/688">https://engkimbs.tistory.com/688</a><br><a href="https://server-engineer.tistory.com/253">https://server-engineer.tistory.com/253</a><br><a href="http://egloos.zum.com/springmvc/v/504151">http://egloos.zum.com/springmvc/v/504151</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;sub&gt; Spring MVC의 동작 순서에 대해 좀 더 명확히 파악 할 수 있도록 포스트를 남겨봅니다. &lt;/sub&gt;&lt;/p&gt;
&lt;h2 id=&quot;Spring-MVC-프로젝트의-기본-구조&quot;&gt;&lt;a href=&quot;#Spring-MVC-프로젝트의-기본-구조&quot; c</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="sequence" scheme="http://jakezo.github.io/tags/sequence/"/>
    
  </entry>
  
  <entry>
    <title>Get,Post</title>
    <link href="http://jakezo.github.io/2021/01/17/Get-Post/"/>
    <id>http://jakezo.github.io/2021/01/17/Get-Post/</id>
    <published>2021-01-17T12:42:38.000Z</published>
    <updated>2021-01-17T12:52:14.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP는 웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜입니다. 클라이언트가 HTTP 프로토콜을 통해 서버에게 요청을 보내면 서버는 요청에 맞는 응답을 클라이언트에게 전송합니다. 이 때, HTTP 요청에 포함되는 HTTP 메소드는 서버가 요청을 수행하기 위해 해야할 행동을 표시하는 용도로 사용합니다. 이 HTTP 메소드 중 GET과 POST의 특징과 차이점을 알아보겠습니다.</p><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>HTTP/1.1 스펙인 RFC2616의 Section9.3에 따르면 GET은 서버로부터 정보를 조회하기 위해 설계된 메소드입니다.<br>GET은 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송합니다. URL의 끝에 ?와 함께 이름과 값으로 쌍을 이루는 요청 파라미터를 쿼리스트링이라고 부릅니다. 만약, 요청 파라미터가 여러 개이면 &amp;로 연결합니다. 쿼리스트링을 사용하게 되면 URL에 조회 조건을 표시하기 때문에 특정 페이지를 링크하거나 북마크할 수 있습니다.</p><p>쿼리스트링을 포함한 URL의 샘플은 아래와 같습니다. 여기서 요청 파라미터명은 name1, name2이고, 각각의 파라미터는 value1, value2라는 값으로 서버에 요청을 보내게 됩니다.<br>그리고 GET은 불필요한 요청을 제한하기 위해 요청이 캐시될 수 있습니다. js, css, 이미지 같은 정적 컨텐츠는 데이터양이 크고, 변경될 일이 적어서 반복해서 동일한 요청을 보낼 필요가 없습니다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해두고, 동일한 요청이 발생할 때 서버로 요청을 보내지 않고 캐시된 데이터를 사용합니다. 그래서 프론트엔드 개발을 하다보면 정적 컨텐츠가 캐시돼 컨텐츠를 변경해도 내용이 바뀌지 않는 경우가 종종 발생합니다. 이 때는 브라우저의 캐시를 지워주면 다시 컨텐츠를 조회하기 위해 서버로 요청을 보내게 됩니다.<br><sub>기본값</sub></p><hr><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST는 리소스를 생성/변경하기 위해 설계되었기 때문에 GET과 달리 전송해야될 데이터를 HTTP 메세지의 Body에 담아서 전송합니다. HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송할 수 있습니다. 그래서 POST 요청은 GET과 달리 대용량 데이터를 전송할 수 있습니다. 이처럼 POST는 데이터가 Body로 전송되고 내용이 눈에 보이지 않아 GET보다 보안적인 면에서 안전하다고 생각할 수 있지만, POST 요청도 크롬 개발자 도구, Fiddler와 같은 툴로 요청 내용을 확인할 수 있기 때문에 민감한 데이터의 경우에는 반드시 암호화해 전송해야 합니다.</p><p>그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야 합니다. 데이터 타입을 표시하지 않으면 서버는 내용이나 URL에 포함된 리소스의 확장자명 등으로 데이터 타입을 유추합니다. 만약, 알 수 없는 경우에는 application/octet-stream로 요청을 처리합니다.<br><sub>Update등에 쓰임</sub></p><h2 id="Get과-Post의-차이"><a href="#Get과-Post의-차이" class="headerlink" title="Get과 Post의 차이"></a>Get과 Post의 차이</h2><p>GET은 Idempotent, POST는 Non-idempotent하게 설계되었습니다.<br>Idempotent(멱등)은 수학적 개념으로 다음과 같이 나타낼 수 있습니다.</p><p>수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질</p><p>즉, 멱등이라는 것은 동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나야 합니다.<br>여기서 GET이 Idempotent하도록 설계되었다는 것은 GET으로 서버에게 동일한 요청을 여러 번 전송하더라도 동일한 응답이 돌아와야 한다는 것을 의미합니다. 이에 따라 GET은 설계원칙에 따라 서버의 데이터나 상태를 변경시키지 않아야 Idempotent하기 때문에 주로 조회를 할 때에 사용해야합니다. 예를 들어, 브라우저에서 웹페이지를 열어보거나 게시글을 읽는 등 조회를 하는 행위는 GET으로 요청하게 됩니다.</p><p>반대로 POST는 Non-idempotent하기 때문에 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있습니다. 이에 따라 POST는 서버의 상태나 데이터를 변경시킬 때 사용됩니다. 게시글을 쓰면 서버에 게시글이 저장이 되고, 게시글을 삭제하면 해당 데이터가 없어지는 등 POST로 요청을 하게 되면 서버의 무언가는 변경되도록 사용됩니다. 이처럼 POST는 <code>생성</code>, <code>수정</code>, <code>삭제</code>에 사용할 수 있지만, 생성에는 POST, 수정은 PUT 또는 PATCH, 삭제는 DELETE가 더 용도에 맞는 메소드라고 할 수 있습니다.</p><p>GET과 POST는 이처럼 큰 차이가 있기 때문에 설계원칙에 따라 적절한 용도로 사용해야합니다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;HTTP는 웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜입니다. 클라이언트</summary>
      
    
    
    
    <category term="HTTP" scheme="http://jakezo.github.io/categories/HTTP/"/>
    
    
    <category term="Get" scheme="http://jakezo.github.io/tags/Get/"/>
    
    <category term="Post" scheme="http://jakezo.github.io/tags/Post/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://jakezo.github.io/2021/01/17/Spring-Bean/"/>
    <id>http://jakezo.github.io/2021/01/17/Spring-Bean/</id>
    <published>2021-01-17T07:38:23.000Z</published>
    <updated>2021-06-08T06:32:57.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Bean-이란"><a href="#Spring-Bean-이란" class="headerlink" title="Spring Bean 이란"></a>Spring Bean 이란</h2><img src="https://i.esdrop.com/d/9u1vAcOPrd.png"/><ul><li><p>Spring에서 POJO(plain, old java object)를 ‘Beans’라고 부른다.</p></li><li><p>Beans는 애플리케이션의 핵심을 이루는 객체이며, Spring IoC(Inversion of Control) 컨테이너에 의해 인스턴스화, 관리, 생성된다.</p></li><li><p>Beans는 우리가 컨테이너에 공급하는 설정 메타 데이터(XML 파일)에 의해 생성된다.</p><ul><li>컨테이너는 이 메타 데이터를 통해 Bean의 생성, Bean Life Cycle, Bean Dependency(종속성) 등을 알 수 있다.</li></ul></li><li><p>애플리케이션의 객체가 지정되면, 해당 객체는 getBean() 메서드를 통해 가져올 수 있다.</p></li></ul><h2 id="Spring-Bean의-정의"><a href="#Spring-Bean의-정의" class="headerlink" title="Spring Bean의 정의"></a>Spring Bean의 정의</h2><ul><li>일반적으로 XML 파일에 정의한다.</li><li>주요 속성<ul><li>class(필수): 정규화된 자바 클래스 이름</li><li>id: bean의 고유 식별자</li><li>scope: 객체의 범위 (sigleton, prototype)</li><li>constructor-arg: 생성 시 생성자에 전달할 인수</li><li>property: 생성 시 bean setter에 전달할 인수</li><li>init method와 destroy method</li></ul></li></ul><h3 id="XML-based-configuration-file"><a href="#XML-based-configuration-file" class="headerlink" title="XML based configuration file"></a>XML based configuration file</h3><pre><code class="xml">&lt;!-- A simple bean definition --&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;&lt;/bean&gt;&lt;!-- A bean definition with scope--&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;&lt;!-- A bean definition with property --&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;    &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;&lt;/bean&gt;&lt;!-- A bean definition with initialization method --&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot; init-method=&quot;...&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="Spring-Bean-Scope"><a href="#Spring-Bean-Scope" class="headerlink" title="Spring Bean Scope"></a>Spring Bean Scope</h2><ul><li><p>스프링은 기본적으로 모든 bean을 singleton으로 생성하여 관리한다.</p><ul><li>구체적으로는 애플리케이션 구동 시 JVM 안에서 스프링이 bean마다 하나의 객체를 생성하는 것을 의미한다.</li><li>그래서 우리는 스프링을 통해서 bean을 제공받으면 언제나 주입받은 bean은 동일한 객체라는 가정하에서 개발을 한다.</li></ul></li><li><p>request, session, global session의 Scope는 일반 Spring 어플리케이션이 아닌, Spring MVC Web Application에서만 사용된다.</p></li></ul><img src="https://i.esdrop.com/d/yIIIfm3kC0.png"/><h3 id="1-Singleton"><a href="#1-Singleton" class="headerlink" title="1. Singleton"></a>1. Singleton</h3><ul><li>‘singleton’ bean은 Spring 컨테이너에서 <strong>한 번</strong> 생성된다. <ul><li>컨테이너가 사라질 때 bean도 제거된다.</li></ul></li><li>생성된 하나의 인스턴스는 single beans cache에 저장되고, 해당 bean에 대한 요청과 참조가 있으면 캐시된 객체를 반환한다.<ul><li>즉, 하나만 생성되기 때문에 동일한 것을 참조한다.</li></ul></li><li>기본적으로 모든 bean은 scope이 명시적으로 지정되지 않으면 singleton이다.</li></ul><img src="https://i.esdrop.com/d/QAhMdYTI4I.png"/><ul><li>xml 설정<ul><li><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</code></li></ul></li><li>annotation 설정<ul><li>대상 클래스에 <code>@Scope(&quot;singletone&quot;)</code></li></ul></li></ul><h3 id="2-Prototype"><a href="#2-Prototype" class="headerlink" title="2. Prototype"></a>2. Prototype</h3><ul><li>‘prototype’ bean은 모든 요청에서 <strong>새로운</strong> 객체를 생성하는 것을 의미한다.<ul><li>즉, prototype bean은 의존성 관계의 bean에 주입 될 때 새로운 객체가 생성되어 주입된다.</li><li>정상적인 방식으로 gc에 의해 bean이 제거된다.</li></ul></li></ul><img src="https://i.esdrop.com/d/kSoen0z9et.png"/><ul><li>xml 설정<ul><li><code>&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</code></li></ul></li><li>annotation 설정<ul><li>대상 클래스에 <code>@Scope(&quot;prototype&quot;)</code></li></ul></li></ul><p><mark>참고</mark></p><ul><li>싱글톤으로 적합한 객체 <ol><li>상태가 없는 공유 객체: 상태를 가지고 있지 않은 객체는 동기화 비용이 없다. 따라서 매번 이 객체를 참조하는 곳에서 새로운 객체를 생성할 이유가 없다.</li><li>읽기용으로만 상태를 가진 공유 객체: 1번과 유사하게 상태를 가지고 있으나 읽기 전용이므로 여전히 동기화 비용이 들지 않는다. 매 요청마다 새로운 객체 생성할 필요가 없다. </li><li>공유가 필요한 상태를 지닌 공유 객체: 객체 간의 반드시 공유해야 할 상태를 지닌 객체가 하나 있다면,  이 경우에는 해당 상태의 쓰기를 가능한 동기화 할 경우 싱글톤도 적합하다.</li><li>쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체: 애플리케이션 안에서 정말로 사용빈도가 높다면, 쓰기 접근에 대한 동기화 비용을 감안하고서라도 싱글톤을 고려할만하다. 이 방법은 1. 장시간에 걸쳐 매우 많은 객체가 생성될 때, 2. 해당 객체가 매우 작은 양의 쓰기상태를 가지고 있을 때, 3. 객체 생성비용이 매우 클 때에 유용한 선택이 될 수 있다.</li></ol></li><li>비싱글톤으로 적합한 객체<ol><li>쓰기가 가능한 상태를 지닌 객체: 쓰기가 가능한 상태가 많아서 동기화 비용이 객체 생성 비용보다 크다면 싱글톤으로 적합하지 않다.</li><li>상태가 노출되지 않은 객체: 일부 제한적인 경우, 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존객체와는 독립적으로 작업을 수행하는 의존 객체가 있다면 싱글톤보다 비싱글톤 객체를 사용하는 것이 더 나을 수 있다.</li></ol></li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><ul><li>PetOwner Class</li></ul><pre><code class="java">package com.spring;public class PetOwner &#123;    String userName;    public AnimalType animal;    public PerOwner(AnimalType animal) &#123; this.animal = animal; &#125;    public String getUserName() &#123;        System.out.println(&quot;Person name is &quot; + , userName);        return userName;    &#125;    public void setUserName(String userName) &#123; this.userName = userName; &#125;    public void play() &#123; animal.sound(); &#125;&#125;</code></pre><ul><li>MainApp Class</li></ul><pre><code class="java">package com.spring;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123;    public static void main(String[] args) &#123;        /* main함수에서 Contaier를 생성 */         // 설정 파일은 인자로 넣고, 해당 설정 파일에 맞게 bean들을 만든다.        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;com/spring/beans/bean.xml&quot;);        // getBean()을 통해 bean의 주소값을 가져온다.          PetOwner person1 = (PerOwner) context.getBean(&quot;petOwner&quot;);        person1.setUserName(&quot;Alice&quot;);        person1.getUserName();        PetOwner person2 = (PerOwner) context.getBean(&quot;petOwner&quot;);        person2.getUserName();        context.close();    &#125; &#125;</code></pre><ul><li>bean.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd&quot;&gt;    &lt;bean id=&quot;dog&quot; class=&quot;com.spring.Dog&quot;&gt;        &lt;property name=&quot;myName&quot; value=&quot;poodle&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.spring.Cat&quot;&gt;        &lt;property name=&quot;myName&quot; value=&quot;bella&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;petOwner&quot; class=&quot;com.spring.PetOwner&quot; scope=&quot;singleton&quot;&gt;        &lt;constructor-arg name=&quot;animal&quot; ref=&quot;dog&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>결과 <ul><li><code>scope=&quot;singleton&quot;</code> 인 경우<ul><li>Person name is Alice</li><li>Person name is Alice</li></ul></li><li><code>scope=&quot;prototype&quot;</code> 인 경우<ul><li>Person name is Alice</li><li>Person name is null</li></ul></li></ul></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><blockquote><ul><li><a href="https://www.slipp.net/wiki/pages/viewpage.action?pageId=25528177">https://www.slipp.net/wiki/pages/viewpage.action?pageId=25528177</a></li><li><a href="https://docs.spring.io/spring/docs/4.2.5.RELEASE/spring-framework-reference/html/beans.html#beans-factory-scopes">https://docs.spring.io/spring/docs/4.2.5.RELEASE/spring-framework-reference/html/beans.html#beans-factory-scopes</a></li><li><a href="http://javaslave.tistory.com/45">http://javaslave.tistory.com/45</a></li><li><a href="https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html">https://gmlwjd9405.github.io/2018/08/08/abstract-factory-pattern.html</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-Bean-이란&quot;&gt;&lt;a href=&quot;#Spring-Bean-이란&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean 이란&quot;&gt;&lt;/a&gt;Spring Bean 이란&lt;/h2&gt;&lt;img src=&quot;https://i.esdro</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="bean" scheme="http://jakezo.github.io/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>spring-Webmaker02</title>
    <link href="http://jakezo.github.io/2021/01/14/spring-Webmaker02/"/>
    <id>http://jakezo.github.io/2021/01/14/spring-Webmaker02/</id>
    <published>2021-01-14T09:39:36.000Z</published>
    <updated>2021-01-20T02:48:41.462Z</updated>
    
    <content type="html"><![CDATA[<p>웹메이커</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;웹메이커&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="board" scheme="http://jakezo.github.io/tags/board/"/>
    
  </entry>
  
  <entry>
    <title>spring-quiz2</title>
    <link href="http://jakezo.github.io/2021/01/14/spring-quiz2/"/>
    <id>http://jakezo.github.io/2021/01/14/spring-quiz2/</id>
    <published>2021-01-13T16:22:16.000Z</published>
    <updated>2021-01-13T16:34:46.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-으로-계산기-만들기"><a href="#Spring-으로-계산기-만들기" class="headerlink" title="Spring 으로 계산기 만들기"></a>Spring 으로 계산기 만들기</h2><p><sub>클릭 할 때마다 아래와 같이 계산이 되는 계산기를 만들어 본다</sub></p><img src="https://i.esdrop.com/d/d5aoD5pVBH.png"/><p><sub>이번엔 만든 순서대로 한번 구성해 보았습니다</sub></p><h3 id="index-jsp"><a href="#index-jsp" class="headerlink" title="index.jsp"></a>index.jsp</h3><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;calc&quot;&gt;        첫 번째 수: &lt;input type=&quot;text&quot; name=&quot;n1&quot; /&gt;&lt;br/&gt;        두 번째 수: &lt;input type=&quot;text&quot; name=&quot;n2&quot; /&gt;&lt;br/&gt;        &lt;input type=&quot;hidden&quot; name=&quot;btn&quot; value=&quot;덧셈&quot; /&gt;        &lt;button&gt;덧셈&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>위 내용을 토대로 Dto 를 만들러 갑니다.</li></ul><h3 id="Dto"><a href="#Dto" class="headerlink" title="Dto"></a>Dto</h3><blockquote><p>Calculator.java</p></blockquote><pre><code class="java">package com.koreait.mvc10.dto;public class Calculator &#123;    private int n1;    private int n2;    private String btn;    private double result;    private String viewName;    private String op;    public Calculator() &#123;    &#125;    // method    public int getN1() &#123;        return n1;    &#125;    public void setN1(int n1) &#123;        this.n1 = n1;    &#125;    public int getN2() &#123;        return n2;    &#125;    public void setN2(int n2) &#123;        this.n2 = n2;    &#125;    public String getBtn() &#123;        return btn;    &#125;    public void setBtn(String btn) &#123;        this.btn = btn;    &#125;    public double getResult() &#123;        return result;    &#125;    // 스스로 계산하는 setResult() 메소드로 변경합니다.    public void setResult() &#123;        if (btn.equals(&quot;덧셈&quot;)) &#123;            result = n1 + n2;            // 덧셈 후에는 뺄셈입니다.            btn =&quot;뺄셈&quot;;            // 덧셈 결과는 result.jsp에서 보여줍니다.            viewName=&quot;result&quot;;            // result.jsp에서 보여줄 연산 기호는 + 입니다            op = &quot;+&quot;;        &#125; else if (btn.equals(&quot;뺄셈&quot;)) &#123;            result = n1 - n2;            btn = &quot;곱셈&quot;;            viewName=&quot;result&quot;;            op =&quot;-&quot;;        &#125;else if(btn.equals(&quot;곱셈&quot;)) &#123;            result = n1 * n2;            btn = &quot;나눗셈&quot;;            viewName=&quot;result&quot;;            op=&quot;*&quot;;        &#125;else if(btn.equals(&quot;나눗셈&quot;)) &#123;            result = (double)n1 / n2;            btn =&quot;초기화면&quot;;            viewName = &quot;result&quot;;            op = &quot;/&quot;;        &#125; else if(btn.equals(&quot;초기화면&quot;))&#123;            viewName =&quot;index&quot;;        &#125;    &#125;    public String getViewName() &#123;        return viewName;    &#125;    public void setViewName(String viewName) &#123;        this.viewName = viewName;    &#125;    public String getOp() &#123;        return op;    &#125;    public void setOp(String op) &#123;        this.op = op;    &#125;&#125;</code></pre><p><sub>스스로 계산사는 메소드로 변경한 것과 operation을 넣은것이 중요</sub></p><h3 id="result-jsp"><a href="#result-jsp" class="headerlink" title="result.jsp"></a>result.jsp</h3><pre><code class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;calc&quot;&gt;        첫 번째 수: $&#123;calculator.n1&#125; &lt;br/&gt;        두 번째 수: $&#123;calculator.n2&#125; &lt;br/&gt;        $&#123;calculator.n1&#125; $&#123;calculator.op&#125; $&#123;calculator.n2&#125; = $&#123;calculator.result&#125; &lt;br/&gt;        &lt;input type=&quot;hidden&quot; name=&quot;n1&quot; value=&quot;$&#123;calculator.n1&#125;&quot; /&gt;        &lt;input type=&quot;hidden&quot; name=&quot;n2&quot; value=&quot;$&#123;calculator.n2&#125;&quot; /&gt;        &lt;input type=&quot;hidden&quot; name=&quot;btn&quot; value=&quot;$&#123;calculator.btn&#125;&quot; /&gt;        &lt;button&gt;$&#123;calculator.btn&#125;&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><sub> 결과 화면을 먼저 예측해서 만들어 본다 </sub></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><blockquote><p>가장중요!!!</p></blockquote><pre><code class="java">package com.koreait.mvc10.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import com.koreait.mvc10.dto.Calculator;@Controllerpublic class MyController &#123;        @RequestMapping(value= &#123;&quot;/&quot;,&quot;index&quot;&#125;, method=RequestMethod.GET)            public String index() &#123;            return &quot;index&quot;;        &#125;        @RequestMapping(value=&quot;calc&quot;,  method=RequestMethod.GET)        public String calc(Calculator calculator) &#123;        // 뷰(JSP)로 전달할 데이터를 model 에 저장합니다.        // 저장할 때 속성(attribute)로 저장합니다.(파라미터가 아닙니다.)        // public String calc(Calculator calculator, Model model) &#123;        // model.addAttribute(&quot;calculator&quot;,calculator); 모델을 사용한다면 이렇게 바뀝니다.            calculator.setResult(); // 연산이 수행됩니다.            if(calculator.getViewName().equals(&quot;result&quot;)) &#123;            return calculator.getViewName(); // forward 합니다.(result.jsp가 뷰인 경우입니다.)(파라미터 가지고 가야하는 경우!)            &#125;else &#123;                //return &quot;redirect:&quot; + calculator.getViewName(); // index.jsp로 이동하는 매핑값(index)                return &quot;redirect:/&quot;; // index.jsp로 이동하는 매핑값(/) 을 이용합니다.. (매핑은 새로운 커멘드를 호출하기 위해있는거임)            &#125;        &#125;&#125;</code></pre><p><strong>중요!!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring-으로-계산기-만들기&quot;&gt;&lt;a href=&quot;#Spring-으로-계산기-만들기&quot; class=&quot;headerlink&quot; title=&quot;Spring 으로 계산기 만들기&quot;&gt;&lt;/a&gt;Spring 으로 계산기 만들기&lt;/h2&gt;&lt;p&gt;&lt;sub&gt;클릭 할 </summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="calculator" scheme="http://jakezo.github.io/tags/calculator/"/>
    
  </entry>
  
  <entry>
    <title>spring-Webmaker-게시판</title>
    <link href="http://jakezo.github.io/2021/01/14/spring-Webmaker/"/>
    <id>http://jakezo.github.io/2021/01/14/spring-Webmaker/</id>
    <published>2021-01-13T15:15:25.000Z</published>
    <updated>2021-01-13T16:38:31.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lombok과-Spring을-이용해-게시판을-만들어보자"><a href="#lombok과-Spring을-이용해-게시판을-만들어보자" class="headerlink" title="lombok과 Spring을 이용해 게시판을 만들어보자"></a>lombok과 Spring을 이용해 게시판을 만들어보자</h2><h3 id="lombok-이란"><a href="#lombok-이란" class="headerlink" title="lombok 이란"></a>lombok 이란</h3><p>일반적으로 자바개발을 하다보면 Model 을 만들고 각 멤버변수를 접근할수 있는 (각 요소들이 private 접근권한을 가지고 있을때) method 를 만들게 된다. 아래처럼 말이다. (윈도우/이클립스 기준)</p><pre><code class="java">public class Student &#123;    private int id;    private String name;    private int grade;    private String department;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getGrade() &#123;        return grade;    &#125;    public void setGrade(int grade) &#123;        this.grade = grade;    &#125;    public String getDepartment() &#123;        return department;    &#125;    public void setDepartment(String department) &#123;        this.department = department;    &#125;    @Override    public String toString() &#123;        return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, grade=&quot; + grade + &quot;, department=&quot; + department + &quot;]&quot;;    &#125;    &#125;</code></pre><p>이렇게 하는 방법도 있지만 어노테이션 설정으로 적용할수 있는 간단한 라이브러리를 소개하고자 한다. 바로 lombok, 공식 홈페이지 : <a href="https://projectlombok.org/">https://projectlombok.org</a> 설치 및 사용방법은 아주 간단하다. 공식 홈페이지에서 jar를 다운받고 실행, 아래처럼 이클립스 실행파일 경로를 설정해준다음에 인스톨을 누르면 된다. lombok.png maven 환경에서 dependency를 가져오기 위해서는 당연히 추가설정을 해줘야 한다.</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.10&lt;/version&gt; &lt;!--버전은 그때 맞춰서--&gt;&lt;/dependency&gt;</code></pre><p><sub>실제로 코드상에서 사용방법은 다음과 같다. 정말 간단히, 어노테이션만 적용해주면 끝!</sub></p><p><sub>lombok 설치 방법중 중요한 부분만 캡쳐해 보았다 자세한 사항은 따로 검색해 보길 바란다. </sub></p><img src="https://i.esdrop.com/d/Lbw57CuDef.png"/><img src="https://i.esdrop.com/d/FhTRtT45rP.png"/><h2 id="Db설정"><a href="#Db설정" class="headerlink" title="Db설정"></a>Db설정</h2><pre><code class="sql">DROP SEQUENCE SIMPLE_SEQ;CREATE SEQUENCE SIMPLE_SEQSTART WITH 1INCREMENT BY 1MAXVALUE 999999NOCYCLENOCACHE;DROP TABLE SIMPLE;CREATE TABLE SIMPLE(    NO NUMBER PRIMARY KEY,    WRITER VARCHAR2(100),    TITLE VARCHAR2(1000),    CONTENT VARCHAR2(4000),    REGDATE DATE);</code></pre><hr><h2 id="DTO-생성"><a href="#DTO-생성" class="headerlink" title="DTO 생성"></a>DTO 생성</h2><pre><code class="java">package com.koreait.simple1.dto;import java.sql.Date;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@NoArgsConstructor  // 디폴트 생성자를 자동으로 생성해 줍니다.@AllArgsConstructor  // 필드를 이용한 생성자를 자동으로 생성해 줍니다.@Data  // lombok의 애너테이션, getter/setter등을 자동으로 생성해 줍니다.       // Window - Show View - Outline 에서 확인이 가능합니다.public class SimpleDto &#123;    // field    private int no;    private String writer;    private String title;    private String content;    private Date regDate;&#125;</code></pre><p><sub> lombok과 애너테이션들을 이용해 생성자를 자동으로 생성!!<sub></p><hr><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><pre><code class="java">package com.koreait.simple1.dao;import java.sql.Connection;import java.sql.Date;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import javax.naming.Context;import javax.naming.InitialContext;import javax.naming.NamingException;import javax.sql.DataSource;import com.koreait.simple1.dto.SimpleDto;public class SimpleDao &#123;    // Connection Pool 처리는 DataSource 클래스가 합니다.    // 필요한 설정은 톰캣 내부의 context.xml에 있습니다.    // &lt;Resource name=&quot;jdbc/oracle&quot;&gt;을 처리하는 Context 클래스가 필요합니다.    // name에 의한 접근: JNDI    private DataSource dataSource;    // singleton    private SimpleDao() &#123;        // context.xml에 있는 설정을 읽어와서 dataSource를 만듭니다.        try &#123;            Context context = new InitialContext();            dataSource = (DataSource)context.lookup(&quot;java:comp/env/jdbc/oracle&quot;);  // 톰캣이다: java:comp/env/ 나머지는 &lt;Resource&gt;의 name 속성        &#125; catch (NamingException e) &#123;            e.printStackTrace();        &#125;    &#125;    private static SimpleDao simpleDao = new SimpleDao();    public static SimpleDao getInstance() &#123;        return simpleDao;    &#125;    private Connection con;    private PreparedStatement ps;    private ResultSet rs;    private String sql;    private void close(Connection con, PreparedStatement ps, ResultSet rs) &#123;        try &#123;            if (rs != null) &#123; rs.close(); &#125;            if (ps != null) &#123; ps.close(); &#125;            if (con != null) &#123; con.close(); &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    /***** 1. list *****/    public List&lt;SimpleDto&gt; simpleList() &#123;        List&lt;SimpleDto&gt; list = new ArrayList&lt;SimpleDto&gt;();        try &#123;            con = dataSource.getConnection();            sql = &quot;SELECT NO, WRITER, TITLE, CONTENT, REGDATE FROM SIMPLE&quot;;            ps = con.prepareStatement(sql);            rs = ps.executeQuery();  // select문 실행 메소드            while (rs.next()) &#123;                int no = rs.getInt(&quot;NO&quot;);                String writer = rs.getString(&quot;WRITER&quot;);                String title = rs.getString(&quot;TITLE&quot;);                String content = rs.getString(&quot;CONTENT&quot;);                Date regDate = rs.getDate(&quot;REGDATE&quot;);                SimpleDto simpleDto = new SimpleDto(no, writer, title, content, regDate);                list.add(simpleDto);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(con, ps, rs);        &#125;        return list;    &#125;    /***** 2. insert *****/    public void simpleInsert(SimpleDto simpleDto) &#123;        try &#123;            con = dataSource.getConnection();            sql = &quot;INSERT INTO SIMPLE VALUES (SIMPLE_SEQ.NEXTVAL, ?, ?, ?, SYSDATE)&quot;;            ps = con.prepareStatement(sql);            ps.setString(1, simpleDto.getWriter());            ps.setString(2, simpleDto.getTitle());            ps.setString(3, simpleDto.getContent());            ps.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(con, ps, null);        &#125;    &#125;    /***** 3. view *****/    public SimpleDto simpleView(int no) &#123;        SimpleDto simpleDto = null;        try &#123;            con = dataSource.getConnection();            sql = &quot;SELECT * FROM SIMPLE WHERE NO = ?&quot;;            ps = con.prepareStatement(sql);            ps.setInt(1, no);            rs = ps.executeQuery();            if (rs.next()) &#123;                String writer = rs.getString(&quot;WRITER&quot;);                String title = rs.getString(&quot;TITLE&quot;);                String content = rs.getString(&quot;CONTENT&quot;);                Date regDate = rs.getDate(&quot;REGDATE&quot;);                simpleDto = new SimpleDto(no, writer, title, content, regDate);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(con, ps, rs);        &#125;        return simpleDto;    &#125;    /***** 4. delete *****/    public void simpleDelete(int no) &#123;        try &#123;            con = dataSource.getConnection();            sql = &quot;DELETE FROM SIMPLE WHERE NO = ?&quot;;            ps = con.prepareStatement(sql);            ps.setInt(1, no);            ps.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(con, ps, null);        &#125;    &#125;    /***** 5. update *****/    public void simpleUpdate(SimpleDto simpleDto) &#123;        try &#123;            con = dataSource.getConnection();            sql = &quot;UPDATE SIMPLE SET TITLE = ?, CONTENT = ? WHERE NO = ?&quot;;            ps = con.prepareStatement(sql);            ps.setString(1, simpleDto.getTitle());            ps.setString(2, simpleDto.getContent());            ps.setInt(3, simpleDto.getNo());            ps.executeUpdate();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            close(con, ps, null);        &#125;    &#125;&#125;</code></pre><p><sub> 기능 추가될 때마다 추가시켜 나간다</sub></p><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><p><sub>첫번째로 Java interface 를 이용해 모든 커멘드에 기본 인터페이스로 참조될 SimpleCommand.java 생성 </sub></p><h3 id="SimpleCommand"><a href="#SimpleCommand" class="headerlink" title="SimpleCommand"></a>SimpleCommand</h3><pre><code class="java">package com.koreait.simple1.command;import org.springframework.ui.Model;public interface SimpleCommand &#123;    public void execute(Model model);&#125;</code></pre><h3 id="SimpleListCommand"><a href="#SimpleListCommand" class="headerlink" title="SimpleListCommand"></a>SimpleListCommand</h3><pre><code class="java">package com.koreait.simple1.command;import org.springframework.ui.Model;import com.koreait.simple1.dao.SimpleDao;public class SimpleListCommand implements SimpleCommand &#123;    @Override    public void execute(Model model) &#123;        // JSP와 달리 command는 데이터만 처리하면 됩니다.        // VIEW는 컨트롤러가 처리합니다.        model.addAttribute(&quot;list&quot;, SimpleDao.getInstance().simpleList());    &#125;&#125;</code></pre><h3 id="SimpleInsertCommand"><a href="#SimpleInsertCommand" class="headerlink" title="SimpleInsertCommand"></a>SimpleInsertCommand</h3><pre><code class="java">package com.koreait.simple1.command;import java.util.Map;import javax.servlet.http.HttpServletRequest;import org.springframework.ui.Model;import com.koreait.simple1.dao.SimpleDao;import com.koreait.simple1.dto.SimpleDto;public class SimpleInsertCommand implements SimpleCommand &#123;    @Override    public void execute(Model model) &#123;        // 전달 받은 model에는 request가 들어 있어요.        // 그걸 꺼내야 합니다.        // model에 저장된 속성을 직접 꺼내는 방법은 없어요.        // 대신 model은 Map으로 바꾸는 것이 가능합니다. (asMap() 메소드)        // Map으로 바꾸고 나면 Map에서 꺼내는 메소드인 get() 메소드를 이용해서 꺼내면 됩니다.        Map&lt;String, Object&gt; map = model.asMap();        HttpServletRequest request = (HttpServletRequest) map.get(&quot;request&quot;);  // model에 저장된 속성(attribute)을 키 값으로 사용하면 됩니다.        String writer = request.getParameter(&quot;writer&quot;);        String title = request.getParameter(&quot;title&quot;);        String content = request.getParameter(&quot;content&quot;);        SimpleDto simpleDto = new SimpleDto();        simpleDto.setWriter(writer);        simpleDto.setTitle(title);        simpleDto.setContent(content);        SimpleDao.getInstance().simpleInsert(simpleDto);    &#125;&#125;</code></pre><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><pre><code class="java">@Controllerpublic class SimpleController &#123;    // 21_simple 프로젝트는 command들을 new로 생성하는 연습입니다.    // field    private SimpleCommand command;    @RequestMapping(value=&quot;/&quot;, method=RequestMethod.GET)    public String index() &#123;        return &quot;index&quot;;    &#125;    @RequestMapping(value=&quot;simpleList.do&quot;)    public String simpleList(Model model) &#123;        // DB에서 list를 가져와서 simpleListPage.jsp로 이동시킵니다.        // simpleListPage.jsp로 보낼 데이터인 list는 Model에 저장합니다.        // Model에 저장된 데이터를 simpleListPage.jsp으로 보내려면 forward합니다.        /*            SimpleListCommand가 없다면 아래와 같이 작업할 수 있겠습니다.            하지만, 이렇게 하시면 안 됩니다.            SimpleDao simpleDao = SimpleDao.getInstance();            model.addAttribute(&quot;list&quot;, simpleDao.simpleList());            return &quot;simple/simpleListPage&quot;;        */        command = new SimpleListCommand();  // 개발자 직접 생성        command.execute(model);        return &quot;simple/simpleListPage&quot;;  // simple 폴더 아래 simpleListPage.jsp로 forward합니다.    &#125;    @RequestMapping(value=&quot;simpleInsertPage.do&quot;)    public String simpleInsertPage() &#123;        return &quot;simple/simpleInsertPage&quot;;  // simple 폴더 아래 simpleInsertPage.jsp로 forward합니다.    &#125;    @RequestMapping(value=&quot;simpleInsert.do&quot;)    public String simpleInsert(HttpServletRequest request, Model model) &#123;        // SimpleInsertCommand 가 삽입을 담당합니다.        // 모든 command들은 model이 필요합니다.        // SimpleInsertCommand에게 request를 전달하려면?        // 모든 command들은 실행할 때 model만 전달 받습니다.        // 따라서, model에 request를 저장해 둡니다. 그리고 model을 전달합니다.        model.addAttribute(&quot;request&quot;, request);        command = new SimpleInsertCommand();  // 개발자가 직접 생성        command.execute(model);        // return &quot;simple/simpleListPage&quot;;  // insert 후에는 forward하면 안 됩니다.        return &quot;redirect:simpleList.do&quot;;  // insert 후에는 redirect 합니다.    &#125;    &#125;</code></pre><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h3 id="Index-jsp"><a href="#Index-jsp" class="headerlink" title="Index.jsp"></a>Index.jsp</h3><p>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8”%&gt;<br><!DOCTYPE html></p><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Insert title here</title></head><body><pre><code>    &lt;!-- 이동합니다 --&gt;    &lt;a href=&quot;simpleList.do&quot;&gt;간단게시판으로 이동&lt;/a&gt;</code></pre></body></html><p><sub>첫 화면을 먼저 만들어 준다 </sub></p><h3 id="SimpleListPage"><a href="#SimpleListPage" class="headerlink" title="SimpleListPage"></a>SimpleListPage</h3><pre><code class="java">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;td&gt;번호&lt;/td&gt;                &lt;td&gt;작성자&lt;/td&gt;                &lt;td&gt;제목&lt;/td&gt;                &lt;td&gt;작성일&lt;/td&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;c:if test=&quot;$&#123;empty list&#125;&quot;&gt;                &lt;tr&gt;                    &lt;td colspan=&quot;4&quot;&gt;없음&lt;/td&gt;                &lt;/tr&gt;            &lt;/c:if&gt;            &lt;c:if test=&quot;$&#123;not empty list&#125;&quot;&gt;                &lt;c:forEach var=&quot;simpleDto&quot; items=&quot;$&#123;list&#125;&quot;&gt;                    &lt;tr&gt;                        &lt;td&gt;$&#123;simpleDto.no&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;simpleDto.writer&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;simpleDto.title&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;simpleDto.regDate&#125;&lt;/td&gt;                    &lt;/tr&gt;                &lt;/c:forEach&gt;            &lt;/c:if&gt;        &lt;/tbody&gt;        &lt;tfoot&gt;            &lt;tr&gt;                &lt;td colspan=&quot;4&quot;&gt;                    &lt;input type=&quot;button&quot; value=&quot;새글작성하러가기&quot; onclick=&quot;location.href=&#39;simpleInsertPage.do&#39;&quot; /&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tfoot&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><sub> 간단게시판으로 이동하면 보여줄화면이다</sub></p><h3 id="SimpleInsertPage"><a href="#SimpleInsertPage" class="headerlink" title="SimpleInsertPage"></a>SimpleInsertPage</h3><pre><code class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;simpleInsert.do&quot;&gt;        작성자        &lt;input type=&quot;text&quot; name=&quot;writer&quot; /&gt;&lt;br/&gt;        제목        &lt;input type=&quot;text&quot; name=&quot;title&quot; /&gt; &lt;br/&gt;        내용        &lt;input type=&quot;text&quot; name=&quot;content&quot; /&gt;&lt;br/&gt;        &lt;button&gt;작성완료&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><sub> 새글 작성하러 가기로 가면 보여줄 화면이다 </sub></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lombok과-Spring을-이용해-게시판을-만들어보자&quot;&gt;&lt;a href=&quot;#lombok과-Spring을-이용해-게시판을-만들어보자&quot; class=&quot;headerlink&quot; title=&quot;lombok과 Spring을 이용해 게시판을 만들어보자&quot;&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="board" scheme="http://jakezo.github.io/tags/board/"/>
    
  </entry>
  
  <entry>
    <title>spring-Ajax-02</title>
    <link href="http://jakezo.github.io/2021/01/12/spring-Ajax-02/"/>
    <id>http://jakezo.github.io/2021/01/12/spring-Ajax-02/</id>
    <published>2021-01-12T14:00:38.000Z</published>
    <updated>2021-01-20T02:49:42.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring을-이용해-jquery를-이용해-ajax를-호출"><a href="#Spring을-이용해-jquery를-이용해-ajax를-호출" class="headerlink" title="Spring을 이용해 jquery를 이용해 ajax를 호출"></a>Spring을 이용해 jquery를 이용해 ajax를 호출</h2><h3 id="jquery-넣기"><a href="#jquery-넣기" class="headerlink" title="jquery 넣기"></a>jquery 넣기</h3><img src="https://i.esdrop.com/d/c7jkgcazHg.jpg"/><p>사이트 접속 후 minified 코드를 클릭 후</p><p><code>index</code>의 script 위에 script 로 삽입!</p><h3 id="index-jsp"><a href="#index-jsp" class="headerlink" title="index.jsp"></a>index.jsp</h3><p><sub>view -&gt; index.jsp 코드작성<sub></p><pre><code class="html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;%-- jquery CDN --%&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot; integrity=&quot;sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 페이지 로드 이벤트    $(function()&#123;        fn_send1();        fn_send2();    &#125;);    function fn_send1() &#123;        $(&#39;#btn1&#39;).click(function()&#123;            $.ajax(&#123;                url: &#39;getText&#39;,  // RequestMapping의 value를 작성합니다.                type: &#39;get&#39;,  // RequestMapping의 method를 작성합니다.                data: &#39;send=&#39; + $(&#39;#send&#39;).val(),  // controller로 보내는 값(파라미터)                dataType: &#39;text&#39;,  // controller에게서 받아 오는 값의 타입                success: function(responseText) &#123;  // responseText: controller에게서 받아 오는 값, return text;에서 text를 받는 변수가 responseText입니다.                    $(&#39;#content1&#39;).text(responseText.trim());  // trim(): 불필요한 공백 제거                &#125;,                /*                    $(&#39;#content1&#39;) == &lt;div id=&quot;content1&quot;&gt;&lt;/div&gt;                    $(&#39;#content1&#39;).text(responseText) == &lt;div id=&quot;content1&quot;&gt;responseText&lt;/div&gt;                    $(&#39;#content1&#39;).text() == responseText                */                error: function()&#123;                    alert(&#39;실패&#39;);                &#125;            &#125;);        &#125;);    &#125;    function fn_send2() &#123;        $(&#39;#btn2&#39;).click(function()&#123;            $.ajax(&#123;                url: &#39;getJson&#39;,                type: &#39;post&#39;,                data: &#39;send=&#39; + $(&#39;#send&#39;).val(),                dataType: &#39;json&#39;,  // return 되는 데이터가 json이다.                success: function(responseObj) &#123;                    // responseObj는 json 데이터이므로,                    // 자바스크립트는 객체로 처리하면 됩니다.                    // 객체.프로퍼티   또는  객체[&#39;프로퍼티&#39;]  방법이 가능합니다.                    $(&#39;#content2&#39;).empty();                    $(&#39;#content2&#39;).append(&#39;&lt;ul&gt;&lt;li&gt;&#39; + responseObj.send + &#39;&lt;/li&gt;&#39;);                    $(&#39;#content2&#39;).append(&#39;&lt;li&gt;&#39; + responseObj.exist + &#39;&lt;/li&gt;&lt;/ul&gt;&#39;);                &#125;,                error: function() &#123;                    alert(&#39;실패&#39;);                &#125;            &#125;);        &#125;);    &#125;&lt;/script&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form&gt;        보내는 값&lt;br/&gt;        &lt;input type=&quot;text&quot; id=&quot;send&quot; name=&quot;send&quot; /&gt;&lt;br/&gt;&lt;br/&gt;        &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;일반텍스트&quot; /&gt;&lt;br/&gt;        &lt;div id=&quot;content1&quot;&gt;&lt;/div&gt;&lt;br/&gt;        &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;JSON&quot; /&gt;&lt;br/&gt;        &lt;div id=&quot;content2&quot;&gt;&lt;/div&gt;&lt;br/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="컨트롤러"><a href="#컨트롤러" class="headerlink" title="컨트롤러"></a>컨트롤러</h3><pre><code class="java">@Controllerpublic class MyController &#123;    @RequestMapping(value=&quot;/&quot;,                    method=RequestMethod.GET)    public String index() &#123;        return &quot;index&quot;;    &#125;    @RequestMapping(value=&quot;getText&quot;,                    method=RequestMethod.GET,                    produces=&quot;text/plain; charset=utf-8&quot;)  // return text; 할 때  text가 &quot;text/plain&quot; 타입입니다.    @ResponseBody  // return 하는 데이터는 응답입니다. (뷰나 다른 매핑값이 아니고, 데이터를 반환합니다.)    public String getText(@RequestParam(value=&quot;send&quot;) String send) &#123;        String text = send + &quot;를 받았습니다.&quot;;        // ajax는 반환하는(return) 값이 &quot;뷰&quot;도 아니고, &quot;다른 매핑값&quot;도 아닙니다.        // 실제로 데이터(텍스트, json, xml 등)를 반환합니다.        return text;  // text는 데이터를 의미합니다. return 하는 데이터는 요청한 곳으로 보내는 데이터입니다. 즉 응답(response)하는 방식입니다.    &#125;    @RequestMapping(value=&quot;getJson&quot;,                    method=RequestMethod.POST,                    produces=&quot;application/json; charset=utf-8&quot;)    /*        produces=MediaType.APPLICATION_JSON_VALUE        produces=&quot;application/json&quot;    */    @ResponseBody    public String getJson(@RequestParam(&quot;send&quot;) String send) &#123;        // json 데이터를 넘겨 주기        JSONObject obj = new JSONObject();        obj.put(&quot;send&quot;, send);        obj.put(&quot;exist&quot;, send.isEmpty() ? &quot;없음&quot; : &quot;있음&quot;);        return obj.toJSONString();        // send가 있다면,        // return &#123;&quot;send&quot;: &quot;보낸데이터&quot;, &quot;exist&quot;: &quot;있음&quot;&#125;;        // send가 없다면,        // return &#123;&quot;send&quot;: &quot;&quot;, &quot;exist&quot;: &quot;없음&quot;&#125;;        // return 하는 데이터가 JSON이므로        // 1. @ResponseBody 가 필요하고, (return 하는 것이 뷰나 다른 매핑값이 아니라 &quot;데이터&quot;이다.)        // 2. produces=&quot;application/json; charset=utf-8&quot; 이 필요하다.    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring을-이용해-jquery를-이용해-ajax를-호출&quot;&gt;&lt;a href=&quot;#Spring을-이용해-jquery를-이용해-ajax를-호출&quot; class=&quot;headerlink&quot; title=&quot;Spring을 이용해 jquery를 이용해 ajax</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    <category term="JQUERY" scheme="http://jakezo.github.io/categories/Spring/WEB/JQUERY/"/>
    
    
    <category term="AJAX" scheme="http://jakezo.github.io/tags/AJAX/"/>
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="JQUERY" scheme="http://jakezo.github.io/tags/JQUERY/"/>
    
  </entry>
  
  <entry>
    <title>spring-Ajax-01 Ajax시작</title>
    <link href="http://jakezo.github.io/2021/01/12/spring-Ajax-01/"/>
    <id>http://jakezo.github.io/2021/01/12/spring-Ajax-01/</id>
    <published>2021-01-12T13:30:59.000Z</published>
    <updated>2021-01-20T02:49:36.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery의-Ajax-사용하기"><a href="#jQuery의-Ajax-사용하기" class="headerlink" title="jQuery의 Ajax 사용하기"></a>jQuery의 Ajax 사용하기</h1><h2 id="Ajax란"><a href="#Ajax란" class="headerlink" title="Ajax란?"></a>Ajax란?</h2><p><code>Ajax</code>(Asynchronous JavaScript and XML)란 비동기 방식의 Javascript와 XML을 가리킵니다. </p><table><thead><tr><th align="center">동기 방식</th><th align="center">비동기 방식</th></tr></thead><tbody><tr><td align="center">서버에 신호를 보냈을 떄 응답이 돌아와야 다음 동작을 수행한다.</td><td align="center">서버에 신호를 보냈을 때 응답 상태와 상관없이 다음 동작을 수행할 수 있다.</td></tr></tbody></table><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax?"></a>Ajax?</h3><p>Ajax를 이용하는 이유는 화면 전환 없이 클라이언트(사용자 컴퓨터)와 서버간에 XML, JSON(JavaScript Object Notation), 텍스트, HTML 등의 정보를 교하기 위해서입니다. <code>Ajax가 등장하기 전에는 반드시 서버를 거쳐야만 자료를 요청</code>할 수 있었습니다. 그러나 Ajax를 이용하면 사용자가 서버에 자료를 요청 시 <code>화면의 전환 없이</code> 요청한 자료를 전송받을 수 있습니다. 또 자료를 요청할 경우 어느 정도 시간이 소요되는 동기 방식에 반해 Ajax를 이용하면 클라이언트가 기다릴 필요 없이 다른 작업을 바로 수행할 수 있습니다.</p><hr><h2 id="ajax-메서드"><a href="#ajax-메서드" class="headerlink" title="$.ajax() 메서드"></a>$.ajax() 메서드</h2><p>$.ajax() 메서드는 사용자가 지정한 URL 경로에 파일의 데이터를 전송하고 입력한 URL 경로 파일로부터 용청한 데이터를 불러옵니다.</p><p> 이때 불러올 수 있는 외부 데이터로는 텍스트, HTML, XML, JSON 형식 등이 있으며, 선택한 요소에 Ajax를 이용해 요청한 외부 데이터를 불러옵니다. 옵션은 속성과 값으로 이루어지며, 중괄호{ } 내의 다양한 옵션을 입력할 수 있습니다.</p><p>다음과 같은 형태로 사용됩니다.</p><pre><code class="javascript">$.ajax(&#123;    url: &quot;전송 페이지&quot;(action url),    type: &quot;전송 방식&quot;(get, post),    data: &quot;전송할 데이터&quot;,    dataType: &quot;요청한 데이터 형식&quot;(&quot;html&quot;, &quot;xml&quot;, &quot;json&quot;, &quot;text&quot;, &quot;json&quot;),    success: function(data)&#123;        //전송에 성공하면 실행될 코드;    &#125;,    error: function()&#123;        //전송에 실패하면 실행될 코드;    &#125;&#125;);</code></pre><h2 id="json을-이용한-예시"><a href="#json을-이용한-예시" class="headerlink" title="json을 이용한 예시"></a>json을 이용한 예시</h2><pre><code class="json">    [        &#123;            &quot;name&quot;: &quot;재익&quot;,            &quot;age&quot;: 24,            &quot;addr&quot;: &quot;부천&quot;,            &quot;phone&quot;: &quot;010-1111-2222&quot;        &#125;,        &#123;            &quot;name&quot;: &quot;자이언티&quot;,            &quot;age&quot;: 91,            &quot;addr&quot;: &quot;부산&quot;,            &quot;phone&quot;: &quot;010-333-4444&quot;        &#125;    ]</code></pre><ol start="2"><li><p>위의 json 값을 읽어올 Reader</p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $.ajax(&#123;        url: &#39;DATA.json&#39;,        dataType: &#39;json&#39;,        type: &#39;get&#39;,        success: function(data)&#123;            var result = &#39;&lt;ul&gt;&#39;;            $(data).each(function(i, person)&#123;                result += &#39;&lt;li&gt;&#39; + person.name + &#39;&lt;/li&gt;&#39;;                result += &#39;&lt;li&gt;&#39; + person.age + &#39;&lt;/li&gt;&#39;;                result += &#39;&lt;li&gt;&#39; + person.addr + &#39;&lt;/li&gt;&#39;;                result += &#39;&lt;li&gt;&#39; + person.phone + &#39;&lt;/li&gt;&#39;;            &#125;);            result += &#39;&lt;/ul&gt;&#39;;            $(&#39;body&#39;).html(result);        &#125;,        error: function()&#123;            alert(&#39;실패&#39;);        &#125;    &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><p><sub> 이제 ajax가 spring 에서 쓰이는 방법을 알아보자 <sub></p><p> <a href="https://jakezo.github.io/2021/01/12/spring-Ajax-02/">다음 포스트</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jQuery의-Ajax-사용하기&quot;&gt;&lt;a href=&quot;#jQuery의-Ajax-사용하기&quot; class=&quot;headerlink&quot; title=&quot;jQuery의 Ajax 사용하기&quot;&gt;&lt;/a&gt;jQuery의 Ajax 사용하기&lt;/h1&gt;&lt;h2 id=&quot;Ajax란</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    <category term="WEB" scheme="http://jakezo.github.io/categories/Spring/WEB/"/>
    
    <category term="JQUERY" scheme="http://jakezo.github.io/categories/Spring/WEB/JQUERY/"/>
    
    
    <category term="AJAX" scheme="http://jakezo.github.io/tags/AJAX/"/>
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="JQUERY" scheme="http://jakezo.github.io/tags/JQUERY/"/>
    
  </entry>
  
  <entry>
    <title>spring-07</title>
    <link href="http://jakezo.github.io/2021/01/10/spring-07/"/>
    <id>http://jakezo.github.io/2021/01/10/spring-07/</id>
    <published>2021-01-10T10:05:28.000Z</published>
    <updated>2021-01-10T12:00:01.370Z</updated>
    
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="bean" scheme="http://jakezo.github.io/tags/bean/"/>
    
    <category term="Collection" scheme="http://jakezo.github.io/tags/Collection/"/>
    
    <category term="Map" scheme="http://jakezo.github.io/tags/Map/"/>
    
    <category term="List" scheme="http://jakezo.github.io/tags/List/"/>
    
    <category term="Set" scheme="http://jakezo.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>spring-06 quiz1 bmi</title>
    <link href="http://jakezo.github.io/2021/01/10/spring-06/"/>
    <id>http://jakezo.github.io/2021/01/10/spring-06/</id>
    <published>2021-01-10T09:18:59.000Z</published>
    <updated>2021-01-10T15:35:59.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bmi-계산기를-만들어보자"><a href="#Bmi-계산기를-만들어보자" class="headerlink" title="Bmi 계산기를 만들어보자"></a>Bmi 계산기를 만들어보자</h2><h2 id="결과화면"><a href="#결과화면" class="headerlink" title="결과화면"></a>결과화면</h2><img src="https://i.esdrop.com/d/kbU7NAbqDu.png" /><p><sub> 결과 화면을 미리 보고 만들어보자</sub></p><h2 id="계산기-만들기"><a href="#계산기-만들기" class="headerlink" title="계산기 만들기"></a>계산기 만들기</h2><h3 id="BMICalculator-java"><a href="#BMICalculator-java" class="headerlink" title="BMICalculator.java"></a>BMICalculator.java</h3><pre><code class="java">package com.koreait.quiz2;public class BMICalculator &#123;    // bmi = 몸무게(kg) / 키(m) 제곱    // field    // 저체중(bmi : ~19)     private double normal; // 정상(bmi : 20~25) 20을 저장해둔다.    private double over; // 과체중(bmi : 26~30) 26을 저장해둔다.    private double obesity; // 비만(bmi : 31~)  31을 저장해둔다.    // constructor    public BMICalculator() &#123;    &#125;    // method    public void bmiInfo(double weight, double height) &#123;        double h = height * 0.01;  // cm -&gt; m        double bmi = weight / (h * h);        String state = null;        if ( bmi &gt;= obesity ) &#123;            state = &quot;비만&quot;;        &#125; else if ( bmi &gt;= over ) &#123;            state = &quot;과체중&quot;;        &#125; else if ( bmi &gt;= normal ) &#123;            state = &quot;정상체중&quot;;        &#125; else &#123;            state = &quot;저체중&quot;;        &#125;        System.out.println(&quot;체질량지수: &quot; + bmi + &quot;(&quot; + state + &quot;)&quot;);    &#125;    public double getNormal() &#123;        return normal;    &#125;    public void setNormal(double normal) &#123;        this.normal = normal;    &#125;    public double getOver() &#123;        return over;    &#125;    public void setOver(double over) &#123;        this.over = over;    &#125;    public double getObesity() &#123;        return obesity;    &#125;    public void setObesity(double obesity) &#123;        this.obesity = obesity;    &#125;&#125;</code></pre><p><sub>BMI지수를 구하기 위해서는 공식이 필요하니까<br>필드를 정해주고 bmiCalculator 메서드를 통해 계산 공식을 넣고 setter를 지정한다.</sub></p><h3 id="Person-java"><a href="#Person-java" class="headerlink" title="Person.java"></a>Person.java</h3><pre><code class="java">package com.koreait.quiz2;import java.util.ArrayList;public class Person &#123;    // field    private String name;  // 이름    private double weight; // 몸무게    private double height; // 키    private BMICalculator bmiCalculator;  // bmi 계산기(체질량지수)    private ArrayList&lt;String&gt; hobbies; // 최소 3개의 취미    // constructor    public Person() &#123;    &#125;    // method    public void personInfo() &#123;        System.out.println(&quot;성명: &quot; + name);        System.out.println(&quot;키: &quot; + height);        System.out.println(&quot;몸무게: &quot; + weight);        bmiCalculatorInfo();        System.out.println(&quot;취미: &quot; + hobbies);    &#125;    public void bmiCalculatorInfo() &#123;        bmiCalculator.bmiInfo(weight, height);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public double getWeight() &#123;        return weight;    &#125;    public void setWeight(double weight) &#123;        this.weight = weight;    &#125;    public double getHeight() &#123;        return height;    &#125;    public void setHeight(double height) &#123;        this.height = height;    &#125;    public BMICalculator getBmiCalculator() &#123;        return bmiCalculator;    &#125;    public void setBmiCalculator(BMICalculator bmiCalculator) &#123;        this.bmiCalculator = bmiCalculator;    &#125;    public ArrayList&lt;String&gt; getHobbies() &#123;        return hobbies;    &#125;    public void setHobbies(ArrayList&lt;String&gt; hobbies) &#123;        this.hobbies = hobbies;    &#125;&#125;</code></pre><p><sub> 나의 정보와 관련된 클래스이ㅏㄷ. </sub></p><h3 id="app-context-xml"><a href="#app-context-xml" class="headerlink" title="app-context.xml"></a>app-context.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;bmiCalc&quot; class=&quot;com.koreait.quiz2.BMICalculator&quot;&gt;        &lt;property name=&quot;normal&quot; value=&quot;20&quot; /&gt;        &lt;property name=&quot;over&quot; value=&quot;26&quot; /&gt;        &lt;property name=&quot;obesity&quot; value=&quot;31&quot; /&gt;    &lt;/bean&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.koreait.quiz2.Person&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;앨리스&quot; /&gt;        &lt;property name=&quot;weight&quot; value=&quot;55.5&quot; /&gt;        &lt;property name=&quot;height&quot; value=&quot;165.5&quot; /&gt;        &lt;property name=&quot;bmiCalculator&quot; ref=&quot;bmiCalc&quot; /&gt;        &lt;property name=&quot;hobbies&quot;&gt;            &lt;list&gt;                &lt;value&gt;운동&lt;/value&gt;                &lt;value&gt;여행&lt;/value&gt;                &lt;value&gt;독서&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>특히 중요한 부분은 <code>xml</code> 매핑이다.<br>각 클래스의 setter는 값을 달라고 열어놓기만 하는 상태이고<br>모든 값은 xml에서 해결한다는 것!</p><p><code>bmiCalculator</code></p><p>3개 필드가 setter형태로 존재하므로 꼭 property로 묶어주고 bmi지수대로 값을 지정해준다는 것</p><p>public void bmiCalculator도 신경써야하지 않나? 처음에는 헷갈렸는데</p><p>유심히 보면 person에서 소환하고 있어서 여기서 해결할거니까 신경쓸 것이 없다.</p><p><code>person</code></p><p> 5개의 필드가 setter형태로 존재하므로 property로 묶어주고</p><p>중요한 점은 위에서 유심히 보라고 했던 <code>ArrayList&lt;String&gt; hobbies</code><br>hobbies는 List타입이라는 인터페이스를 가지고 있으므로 List형태로 묶고 value값을 지정해주면 된다.</p><p>또 bmiCalculator는 BMICalculator를 참조한다는 의미로 ref를 써주면 된다.</p><hr><h3 id="PersonMain-java"><a href="#PersonMain-java" class="headerlink" title="PersonMain.java"></a>PersonMain.java</h3><pre><code class="java">package com.koreait.quiz2;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.GenericXmlApplicationContext;public class PersonMain &#123;    public static void main(String[] args) &#123;        AbstractApplicationContext ctx = new GenericXmlApplicationContext(&quot;classpath:app-context2.xml&quot;);        Person p = ctx.getBean(&quot;person&quot;, Person.class);        p.personInfo();        ctx.close();    &#125;&#125;</code></pre><p>그러면 classpath:app-context2.xml로 위치를 지정하고</p><p>ctx에 그 값을 넣어주고</p><p>Person를 가져와서 getBean에서 뽑아오는 person Bean객체를 넣어주고</p><p>내 신상정보 메서드를 소환해서 정하면 원하는 결과값이 나온다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Bmi-계산기를-만들어보자&quot;&gt;&lt;a href=&quot;#Bmi-계산기를-만들어보자&quot; class=&quot;headerlink&quot; title=&quot;Bmi 계산기를 만들어보자&quot;&gt;&lt;/a&gt;Bmi 계산기를 만들어보자&lt;/h2&gt;&lt;h2 id=&quot;결과화면&quot;&gt;&lt;a href=&quot;#결</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="bean" scheme="http://jakezo.github.io/tags/bean/"/>
    
    <category term="Collection" scheme="http://jakezo.github.io/tags/Collection/"/>
    
    <category term="Map" scheme="http://jakezo.github.io/tags/Map/"/>
    
    <category term="List" scheme="http://jakezo.github.io/tags/List/"/>
    
    <category term="Set" scheme="http://jakezo.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>spring-05 애너테이션(annotation) 사용</title>
    <link href="http://jakezo.github.io/2021/01/10/spring-05/"/>
    <id>http://jakezo.github.io/2021/01/10/spring-05/</id>
    <published>2021-01-10T08:02:19.000Z</published>
    <updated>2021-01-10T08:58:39.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="애너테이션-사용"><a href="#애너테이션-사용" class="headerlink" title="애너테이션 사용"></a>애너테이션 사용</h2><h3 id="애너테이션이란"><a href="#애너테이션이란" class="headerlink" title="애너테이션이란"></a>애너테이션이란</h3><ul><li><p>스프링 애너테이션(Annotation)</p><p>  기존에 XML에서 하던 빈 설정을 애너테이션을 이용해서 자바 코드에서 설정하는 방법</p><p>  기능이 복잡해짐에 따라 XML에서 설정하는 것보다 유지 보수가 유리하다.</p><p>  현재 애플리케이션 개발 시 XML 설정 방법과 애너테이션 방법을 혼합해서 사용한다.</p></li></ul><blockquote><p>@Configuration</p></blockquote><p>app-context.xml 하고 같은 일을 하는 클래스이다.</p><h2 id="실전문제"><a href="#실전문제" class="headerlink" title="실전문제"></a>실전문제</h2><blockquote><p>app-context.xml 이 없는 ver</p></blockquote><h3 id="Song-java"><a href="#Song-java" class="headerlink" title="Song.java"></a>Song.java</h3><pre><code class="java">package com.koreait.spring;public class Song &#123;    // field    private String title;    private String genre;    // constructor    public Song() &#123;    &#125;    public Song(String title, String genre) &#123;        super();        this.title = title;        this.genre = genre;    &#125;    // method    public String getTitle() &#123;        return title;    &#125;    public void setTitle(String title) &#123;        this.title = title;    &#125;    public String getGenre() &#123;        return genre;    &#125;    public void setGenre(String genre) &#123;        this.genre = genre;    &#125;    public void songInfo() &#123;        System.out.println(title + &quot;(&quot; + genre + &quot;)&quot;);    &#125;&#125;</code></pre><p><sub>title genre 필드를 만들고 getter setter, 그리고 generate Constructor using fiends 까지 해준다 </sub></p><hr><h3 id="singer-java"><a href="#singer-java" class="headerlink" title="singer.java"></a>singer.java</h3><pre><code class="java">package com.koreait.spring;public class Singer &#123;    // field    private String name;    private Song song;    //constructor    public Singer() &#123;        // TODO Auto-generated constructor stub    &#125;    public Singer(String name, Song song) &#123;        super();        this.name = name;        this.song = song;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Song getSong() &#123;        return song;    &#125;    public void setSong(Song song) &#123;        this.song = song;    &#125;    public void singInfo() &#123;        System.out.println(&quot;이름:&quot; + name );        song.songInfo();    &#125;&#125;</code></pre><p><sub> <code>private Song song</code> 해줌으로써 songInfo(); 를 가져온다 </sub></p><hr><h2 id="Java-스타일-메인"><a href="#Java-스타일-메인" class="headerlink" title="Java 스타일 메인"></a>Java 스타일 메인</h2><pre><code class="java">package com.koreait.spring;public class MainClass &#123;    public static void main(String[] args) &#123;        Song song = new Song();        song.setTitle(&quot;Dynamite&quot;);        song.setGenre(&quot;댄스&quot;);        Singer singer =new Singer();        singer.setName(&quot;BTS&quot;);        singer.setSong(song);        singer.singInfo();    &#125;&#125;</code></pre><hr><h2 id="Spring-Style-Main"><a href="#Spring-Style-Main" class="headerlink" title="Spring Style Main"></a>Spring Style Main</h2><h3 id="AppContext-java"><a href="#AppContext-java" class="headerlink" title="AppContext.java"></a>AppContext.java</h3><blockquote><p>중요!! xml 을 대신한다.</p></blockquote><pre><code class="java">package com.koreait.spring;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;// 애너테이션 사용/**  @Configuration*  *  : 나는 app-context.xml 하고 같은일을 하는 클래스 이다..* */@Configurationpublic class AppContext &#123;   // 메소드 하나당 Bean을 하나 씩 만듭니다.   // Bean 을 만드는 메소드들은 @ 애너테이션을 추가해야 한다.   /*    *  &lt;bean id=&quot;song1&quot; class=&quot;com.koreait.spring.Song&quot;&gt;    *      *  &lt;property name=&quot;title&quot; value=&quot;Dynamite&quot; /&gt;    *  &lt;property name=&quot;genre&quot; value=&quot;댄스&quot; /&gt;    *  &lt;/bean&gt;    *      *  아래 메소드를 위 &lt;bean&gt; 태그와 같은 일을 한다.    *     */   @Bean   // 이 메소드는 Bean 을 만드는 메소드 입니다.   public Song song1() &#123;       Song song = new Song();                    // &lt;bean id=&quot;song1&quot; class=&quot;com.koreait.spring.Song&quot;&gt;       song.setTitle(&quot;Dynamite1&quot;); //  &lt;property name=&quot;title&quot; value=&quot;Dynamite&quot; /&gt;       song.setGenre(&quot;댄스1&quot;);  // &lt;property name=&quot;genre&quot; value=&quot;댄스&quot; /&gt;       return song;   &#125;   /*    &lt;bean id=&quot;song2&quot; class=&quot;com.koreait.spring.Song&quot;&gt;      &lt;constructor-arg value=&quot;Dynamite&quot; /&gt;      &lt;constructor-arg  value=&quot;댄스&quot; /&gt;      &lt;/bean&gt;       아래 메소드는 위 &lt;bean&gt; 태그와 같은 일을 한다.   */   @Bean(name=&quot;song2&quot;)  // @Bean(name=&quot;bean의 id&quot;)    public Song zzzzz() &#123;  // 메소드의 이름 zzzz는 사용되지 않아요.       return new Song(&quot;Dynamite2&quot;, &quot;댄스2&quot;);   &#125;   /*    &lt;bean id=&quot;singer1&quot; class=&quot;com.koreait.spring.Singer&quot;&gt;      &lt;property name=&quot;name&quot;  value=&quot;BTS&quot; /&gt;      &lt;property  name=&quot;song&quot;  ref=&quot;song1&quot; /&gt;      &lt;/bean&gt;       아래 메소드는 위 &lt;bean&gt; 태그와 같은 일을 한다.   */   @Bean   public Singer singer1() &#123;       Singer singer = new Singer();       singer.setName(&quot;BTS3&quot;);       singer.setSong(song1());  // public Song song1()&#123;&#125; 메소드를 호출하면 song1 이라는 Bean 이 반환됩니다.       return singer;   &#125;   /*    &lt;bean id=&quot;singer2&quot; class=&quot;com.koreait.spring.Singer&quot;&gt;            &lt;constructor-arg value=&quot;BTS&quot; /&gt;      &lt;constructor-arg  ref=&quot;song2&quot; /&gt;      &lt;/bean&gt;       아래 메소드는 위 &lt;bean&gt; 태그와 같은 일을 한다.    */   @Bean   public Singer singer2() &#123;       return new Singer(&quot;BTS4&quot;, zzzzz());  // public Song zzzzz()&#123;&#125; 메소드를 호출하면 song2 라는 Bean 이 반환   &#125;&#125;</code></pre><h3 id="SpringMainClass-java"><a href="#SpringMainClass-java" class="headerlink" title="SpringMainClass.java"></a>SpringMainClass.java</h3><pre><code class="java">package com.koreait.spring;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.AbstractApplicationContext;public class SpringMainClass &#123;    public static void main(String[] args) &#123;        // @Configuration 애너테이션을 추가한 AppContext.java 를        // 처리하는 클래스는 AnnotationConfigApplicationContext 입니다.        // AnnotationConfigApplicationContext 클래스는 AbstractApplicationContext 클래스의 서브클래스 입니다.        AbstractApplicationContext ctx = new AnnotationConfigApplicationContext(AppContext.class);        Song s1 = ctx.getBean(&quot;song1&quot;, Song.class);        Song s2 = ctx.getBean(&quot;song2&quot;, Song.class);        s1.songInfo();        s2.songInfo();        Singer gasu1 = ctx.getBean(&quot;singer1&quot;, Singer.class);        Singer gasu2 = ctx.getBean(&quot;singer2&quot;, Singer.class);        gasu1.singInfo();        gasu2.singInfo();        ctx.close();    &#125;&#125;</code></pre><p><sub>AbstractApplicationContext ctx = new AnnotationConfigApplicationContext(AppContext.class);<br>부분 중요 </sub></p><h2 id="결과화면"><a href="#결과화면" class="headerlink" title="결과화면"></a>결과화면</h2><img src="https://i.esdrop.com/d/ogH2VR8S7e.png" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;애너테이션-사용&quot;&gt;&lt;a href=&quot;#애너테이션-사용&quot; class=&quot;headerlink&quot; title=&quot;애너테이션 사용&quot;&gt;&lt;/a&gt;애너테이션 사용&lt;/h2&gt;&lt;h3 id=&quot;애너테이션이란&quot;&gt;&lt;a href=&quot;#애너테이션이란&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="bean" scheme="http://jakezo.github.io/tags/bean/"/>
    
    <category term="Collection" scheme="http://jakezo.github.io/tags/Collection/"/>
    
    <category term="Map" scheme="http://jakezo.github.io/tags/Map/"/>
    
    <category term="List" scheme="http://jakezo.github.io/tags/List/"/>
    
    <category term="Set" scheme="http://jakezo.github.io/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>spring-04 Collection 활용(2)</title>
    <link href="http://jakezo.github.io/2021/01/09/spring-04/"/>
    <id>http://jakezo.github.io/2021/01/09/spring-04/</id>
    <published>2021-01-09T12:57:31.000Z</published>
    <updated>2021-01-10T10:04:01.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="알아볼-내용"><a href="#알아볼-내용" class="headerlink" title="알아볼 내용"></a>알아볼 내용</h2><blockquote><p>app-context 가 두개 있는경우</p></blockquote><p><sub>app-context가 두개가 있는 경우 그리고 porperty 태그를 대신할수 있는 p속성에 대해 알아봅시다</sub></p><h2 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h2><h3 id="Car-java"><a href="#Car-java" class="headerlink" title="Car.java"></a>Car.java</h3><pre><code class="java">package com.koreait.spring;public class Person &#123;    // field    private String name;    private Car myCar;    // constructor    public Person() &#123;    &#125;    // method    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Car getMyCar() &#123;        return myCar;    &#125;    public void setMyCar(Car myCar) &#123;        this.myCar = myCar;    &#125;    public void personInfo() &#123;        System.out.println(&quot;이름: &quot; + name);        myCar.carInfo();    &#125;&#125;</code></pre><blockquote><p><code>personInfo()</code> 부분을 잘 살펴보자</p></blockquote><h3 id="Person-java"><a href="#Person-java" class="headerlink" title="Person.java"></a>Person.java</h3><pre><code class="java">package com.koreait.spring;public class Person &#123;    // field    private String name;    private Car myCar;    // constructor    public Person() &#123;    &#125;    // method    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Car getMyCar() &#123;        return myCar;    &#125;    public void setMyCar(Car myCar) &#123;        this.myCar = myCar;    &#125;    public void personInfo() &#123;        System.out.println(&quot;이름: &quot; + name);        myCar.carInfo();    &#125;&#125;</code></pre><h2 id="기본-Java-방법"><a href="#기본-Java-방법" class="headerlink" title="기본 Java 방법"></a>기본 Java 방법</h2><h3 id="MainClass-java"><a href="#MainClass-java" class="headerlink" title="MainClass.java"></a>MainClass.java</h3><pre><code class="java">package com.koreait.spring;public class MainClass &#123;    public static void main(String[] args) &#123;        Car car = new Car();        car.setModel(&quot;520d&quot;);        car.setPrice(7000);        car.carInfo();        Person person = new Person();        person.setName(&quot;제임스&quot;);        person.setMyCar(car);        person.personInfo();    &#125;&#125;</code></pre><h2 id="Spring-방법"><a href="#Spring-방법" class="headerlink" title="Spring 방법"></a>Spring 방법</h2><h3 id="app-context1-xml"><a href="#app-context1-xml" class="headerlink" title="app-context1.xml"></a>app-context1.xml</h3><p><sub> Namespaces 탭에서 p 속성을 선택해서 <code>&lt;property&gt;</code>태그를 대신 사용한다.<br></sub></p><p><sub>Car 과 Person을 분리해서 xml을 만드는 방식</sub></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- app-context1.xml 에서는 Car만 만들었습니다. --&gt;    &lt;!--        원래 디폴트 생성자 + setter        &lt;bean id=&quot;객체명&quot; class=&quot;클래스명&quot;&gt;            &lt;property name=&quot;필드명&quot; value=&quot;값&quot; /&gt;        &lt;/bean&gt;        Namespaces 탭에서 p 속성을 선택하면 아래와 같이 바꿀 수 있어요.        &lt;bean id=&quot;객체명&quot; class=&quot;클래스명&quot; p:필드명=&quot;값&quot; /&gt;    --&gt;    &lt;!--        Car car = new Car();        car.setModel(&quot;520d&quot;);        car.setPrice(7000);    --&gt;    &lt;bean id=&quot;car&quot; class=&quot;com.koreait.spring.Car&quot; p:model=&quot;520d&quot; p:price=&quot;7000&quot; /&gt;&lt;/beans&gt;</code></pre><h3 id="app-context2-xml"><a href="#app-context2-xml" class="headerlink" title="app-context2.xml"></a>app-context2.xml</h3><pre><code class="xml">&lt;!-- app-context2.xml 에서는 Person만 생성합니다. --&gt;    &lt;!--        Person person = new Person();        person.setName(&quot;제임스&quot;);        person.setMyCar(car);    --&gt;    &lt;bean id=&quot;person&quot; class=&quot;com.koreait.spring.Person&quot; p:name=&quot;제임스&quot; p:myCar-ref=&quot;car&quot; /&gt;&lt;/beans&gt;</code></pre><h3 id="SpringMainClass-java"><a href="#SpringMainClass-java" class="headerlink" title="SpringMainClass.java"></a>SpringMainClass.java</h3><pre><code class="java">package com.koreait.spring;public class SpringMainClass &#123;    public static void main(String[] args) &#123;        String resourceLocation1 = &quot;classpath:app-context1.xml&quot;;        String resourceLocation2 = &quot;classpath:app-context2.xml&quot;;        AbstractApplicationContext ctx = new GenericXmlApplicationContext(resourceLocation1, resourceLocation2);        Person p = ctx.getBean(&quot;person&quot;, Person.class);        // &quot;person&quot; 은 app-Context2.xml 의 bean id        p.personInfo();        ctx.close();        &#125;&#125;</code></pre><p><sub>AbstractApplicationContext ctx = new GenericXmlApplicationContext(resourceLocation1, resourceLocation2);  부분 중요</sub></p><h2 id="결과화면"><a href="#결과화면" class="headerlink" title="결과화면"></a>결과화면</h2><img src="https://i.esdrop.com/d/Ke1fGkw2xh.png" /><p><strong>resuouceLocation</strong>: 이 친구를 통해 <strong>classpath</strong>를 <code>app-Context.xml</code> 로 쓰겠다! 라고</p><p>위치를 지정해주면 스프링 컨테이너(IOC컨테이너)가 만들어진다.</p><p><strong>AbstractApplicationContext</strong> : 컨택스트를 생성하는 인터페이스</p><p><strong>getBean</strong> : <code>app-Context.xml</code>에 지정된 bean id에서 뽑아오겠다 라는 의미이다.</p><p>MyCalculator.class는 해당클래스를 나타낸다.</p><p>즉, 설정파일.xml로 위치를 지정해주고<br><strong>AbstractApplicationContext</strong>라는 인터페이스를 통해서 저장한 파일을 ctx에 담고<br><strong>getBean</strong>을 통해서 <strong>xml</strong>에 있는 클래스와 해당 정보를 담는 것</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;알아볼-내용&quot;&gt;&lt;a href=&quot;#알아볼-내용&quot; class=&quot;headerlink&quot; title=&quot;알아볼 내용&quot;&gt;&lt;/a&gt;알아볼 내용&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;app-context 가 두개 있는경우&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://jakezo.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://jakezo.github.io/tags/Spring/"/>
    
    <category term="bean" scheme="http://jakezo.github.io/tags/bean/"/>
    
    <category term="Collection" scheme="http://jakezo.github.io/tags/Collection/"/>
    
    <category term="Map" scheme="http://jakezo.github.io/tags/Map/"/>
    
    <category term="List" scheme="http://jakezo.github.io/tags/List/"/>
    
    <category term="Set" scheme="http://jakezo.github.io/tags/Set/"/>
    
  </entry>
  
</feed>
